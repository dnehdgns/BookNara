<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>EPUB Viewer (epub.js)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js"></script>
    <style>
        :root{
          --w: 1920px;
          --h: 1080px;
          --page-bg: #ffffff;
          --overlay-w: 100px;

          --menu-h: 72px;
          --menu-gap: 14px;
          --menu-bg: rgba(255,248,238,.58);
          --menu-bd: rgba(255,255,255,.14);
          --menu-txt: rgba(100, 98, 99, .92);
          --menu-muted: rgba(0,0,0,.70);
          --menu-blur: blur(10px);
          --menu-radius: 16px;

          --scrub-h: 10px;
        }

        html, body {
          height: 100%;
          margin: 0;
          background: #fff;
          overflow: hidden;
          font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif;
        }

        .stage {
          width: var(--w);
          height: var(--h);
          margin: 0 auto;
          position: relative;
          transform-origin: top left;
        }

        .reader-shell {
          position: absolute;
          inset: 24px;
          background: var(--page-bg);
          box-shadow: 0 10px 40px rgba(0,0,0,.55);
          border: 1px solid rgba(0,0,0,.18);
          overflow: hidden;
        }

        #viewer {
          position: absolute;
          inset: 0;
          z-index: 1;
        }

        /* ===== 좌/우 오버레이 ===== */
        .nav-overlay {
          position: absolute;
          top: 0;
          bottom: 0;
          width: var(--overlay-w);
          z-index: 9999;
          pointer-events: auto;
          display: none;
          cursor: pointer;
          user-select: none;
        }
        .nav-overlay.show { display: block; }

        .nav-overlay.left {
          left: 0;
          background: linear-gradient(to right, rgba(0,0,0,.28), rgba(0,0,0,0));
        }
        .nav-overlay.right {
          right: 0;
          background: linear-gradient(to left, rgba(0,0,0,.28), rgba(0,0,0,0));
        }

        .nav-overlay .arrow {
          position: absolute;
          top: 50%;
          transform: translateY(-50%);
          width: 56px;
          height: 56px;
          border-radius: 999px;
          background: rgba(0,0,0,.32);
          display: grid;
          place-items: center;
          backdrop-filter: blur(6px);
        }
        .nav-overlay.left .arrow { left: 18px; }
        .nav-overlay.right .arrow { right: 18px; }

        .nav-overlay svg {
          width: 22px;
          height: 22px;
          fill: none;
          stroke: rgba(255,255,255,.92);
          stroke-width: 3;
          stroke-linecap: round;
          stroke-linejoin: round;
        }

        .reader-shell, .nav-overlay { -webkit-user-select: none; user-select: none; }

        .epub-container { z-index: 1; }
        .epub-view { z-index: 2; }
        iframe { position: relative; z-index: 3; }

        /* ===== 로더(임시) ===== */
        .loader {
          position: absolute;
          top: 10px;
          left: 10px;
          z-index: 20000;
          display: flex;
          gap: 8px;
          align-items: center;
          padding: 8px 10px;
          border-radius: 10px;
          background: rgba(0,0,0,.55);
          color: #fff;
          font-size: 13px;
          user-select: none;
        }
        .loader button {
          border: 0;
          cursor: pointer;
          padding: 7px 10px;
          border-radius: 8px;
          background: rgba(255,255,255,.14);
          color: #fff;
        }
        .loader button:hover { background: rgba(255,255,255,.22); }
        .loader .hint { opacity: .85; }

        /* ===== 상/하단 메뉴(슬라이드) ===== */
        .menu-top,
        .menu-bottom {
          position: absolute;
          left: 18px;
          right: 18px;
          z-index: 12000;
          border: 1px solid var(--menu-bd);
          background: var(--menu-bg);
          color: var(--menu-txt);
          border-radius: var(--menu-radius);
          backdrop-filter: var(--menu-blur);
          display: flex;
          align-items: center;
          gap: var(--menu-gap);
          padding: 12px 14px;
          box-shadow: 0 10px 30px rgba(0,0,0,.35);
          will-change: transform, opacity;
          transition: transform 220ms ease, opacity 220ms ease;
          opacity: 0;
          pointer-events: none; /* 닫혀 있을 때 클릭 방지 */
        }

        .menu-top {
          top: 18px;
          height: var(--menu-h);
          transform: translateY(-18px);
          justify-content: space-between;
        }
        .menu-bottom {
          bottom: 18px;
          height: var(--menu-h);
          transform: translateY(18px);
          justify-content: space-between;
        }

        .menus-open .menu-top,
        .menus-open .menu-bottom {
          transform: translateY(0);
          opacity: 1;
          pointer-events: auto;
        }

        .book-title {
          font-weight: 700;
          font-size: 16px;
          letter-spacing: .2px;
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
          max-width: 55%;
        }

        .tool-buttons {
          display: flex;
          align-items: center;
          gap: 10px;
          margin-left: auto;
        }

        .icon-btn {
          width: 40px;
          height: 40px;
          border-radius: 12px;
          border: 1px solid rgba(0,0,0,.14);
          background: rgba(0,0,0,.08);
          color: var(--menu-txt);
          display: grid;
          place-items: center;
          cursor: pointer;
          transition: background 120ms ease, transform 120ms ease;
        }
        .icon-btn:hover { background: rgba(0,0,0,.14); transform: translateY(-1px); }
        .icon-btn:active { transform: translateY(0); }

        .icon-btn svg {
          width: 18px;
          height: 18px;
          stroke: rgba(0,0,0,.92);
          fill: none;
          stroke-width: 2.2;
          stroke-linecap: round;
          stroke-linejoin: round;
        }

        /* ===== 하단 진행바 + 페이지 입력 ===== */
        .progress-wrap{
          display: flex;
          align-items: center;
          gap: 12px;
          width: 100%;
        }

        .progress-range{
          -webkit-appearance: none;
          appearance: none;
          width: 100%;
          height: var(--scrub-h);
          border-radius: 999px;
          outline: none;
          background: rgba(255,255,255,.22);
          border: 1px solid rgba(0,0,0,.25);
          cursor: pointer;
        }
        .progress-range::-webkit-slider-thumb{
          -webkit-appearance: none;
          appearance: none;
          width: 18px;
          height: 18px;
          border-radius: 999px;
          background: rgba(255,255,255,.92);
          border: 2px solid rgba(0,0,0,.25);
        }
        .progress-range::-moz-range-thumb{
          width: 18px;
          height: 18px;
          border-radius: 999px;
          background: rgba(255,255,255,.92);
          border: 2px solid rgba(0,0,0,.25);
        }

        .page-num{
          display: flex;
          align-items: center;
          gap: 6px;
          font-size: 13px;
          color: var(--menu-muted);
          flex: 0 0 auto;
        }

        .page-input{
          width: 62px;
          height: 34px;
          border-radius: 10px;
          border: 1px solid rgba(0,0,0,.37);
          background: rgba(255,255,255,1);
          color: var(--menu-txt);
          padding: 0 10px;
          font-size: 13px;
          outline: none;
        }
        .page-input:focus{
          //border-color: rgba(255,255,255,.30);
          //background: rgba(255,255,255,1);
        }

        /* ===== 내 서재 버튼(메뉴 ON일 때만) ===== */
        .library-fab{
          position: absolute;
          right: 26px;
          bottom: calc(18px + var(--menu-h) + 40px);
          z-index: 13000;
          width: 52px;
          height: 52px;
          border-radius: 18px;
          border: 1px solid rgba(0,0,0,.08);
          background: rgba(255,255,255,.92);
          box-shadow: 0 12px 28px rgba(0,0,0,.25);
          display: grid;
          place-items: center;
          cursor: pointer;
          transition: transform 120ms ease, opacity 200ms ease;
          opacity: 0;
          pointer-events: none;
        }
        .library-fab svg{
          width: 20px;
          height: 20px;
          stroke: rgba(0,0,0,.78);
          fill: none;
          stroke-width: 2.2;
          stroke-linecap: round;
          stroke-linejoin: round;
        }
        .menus-open .library-fab{
          opacity: 1;
          pointer-events: auto;
        }
        .library-fab:hover{ transform: translateY(-1px); }
        .library-fab:active{ transform: translateY(0); }

        @media (max-width: 1920px), (max-height: 1080px) {
          .stage { transform-origin: top left; }
        }
    </style>
</head>
<body>

<div class="loader">
    <h2>9</h2>
    <button id="btnLoad">EPUB 불러오기</button>
    <span class="hint">←/→ · 가장자리(100px) · 책 클릭 메뉴</span>
    <input id="fileInput" type="file" accept=".epub,application/epub+zip" hidden />
</div>

<div class="stage" id="stage">
    <div class="reader-shell" id="shell">
        <div id="viewer"></div>

        <!-- 좌/우 그라데이션 + 화살표 오버레이 -->
        <div class="nav-overlay left" id="navLeft" aria-label="Previous page">
            <div class="arrow" aria-hidden="true">
                <svg viewBox="0 0 24 24"><path d="M15 18l-6-6 6-6"></path></svg>
            </div>
        </div>

        <div class="nav-overlay right" id="navRight" aria-label="Next page">
            <div class="arrow" aria-hidden="true">
                <svg viewBox="0 0 24 24"><path d="M9 6l6 6-6 6"></path></svg>
            </div>
        </div>

        <!-- 상단 메뉴 -->
        <div class="menu-top" id="menuTop">
            <div class="book-title" id="bookTitle"></div>
            <div class="tool-buttons">
                <!-- 패널은 “지금은 신경 X”라서 버튼만 배치 -->
                <button class="icon-btn" title="사전" type="button">
                    <svg viewBox="0 0 24 24"><path d="M4 6h10a4 4 0 0 1 4 4v11H8a4 4 0 0 0-4 4z"/><path d="M8 6v15"/></svg>
                </button>
                <button class="icon-btn" title="TTS" type="button">
                    <svg viewBox="0 0 24 24"><path d="M11 5H7a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h4"/><path d="M15 8a3 3 0 0 1 0 8"/><path d="M17.5 5.5a6 6 0 0 1 0 13"/></svg>
                </button>
                <button class="icon-btn" title="보기설정" type="button">
                    <svg viewBox="0 0 24 24"><path d="M12 3v3"/><path d="M12 18v3"/><path d="M4.22 4.22l2.12 2.12"/><path d="M17.66 17.66l2.12 2.12"/><path d="M3 12h3"/><path d="M18 12h3"/><path d="M4.22 19.78l2.12-2.12"/><path d="M17.66 6.34l2.12-2.12"/><path d="M12 8a4 4 0 1 0 0 8a4 4 0 0 0 0-8z"/></svg>
                </button>
                <button class="icon-btn" title="목차" type="button">
                    <svg viewBox="0 0 24 24"><path d="M8 6h13"/><path d="M8 12h13"/><path d="M8 18h13"/><path d="M3 6h.01"/><path d="M3 12h.01"/><path d="M3 18h.01"/></svg>
                </button>
            </div>
        </div>

        <!-- 하단 메뉴 -->
        <div class="menu-bottom" id="menuBottom">
            <div class="progress-wrap">
                <input id="progressRange" class="progress-range" type="range" min="1" max="1" value="1" step="1" />
                <div class="page-num">
                    <input id="pageInput" class="page-input" type="number" min="1" value="1" />
                    <span>/</span>
                    <span id="pageTotal">1</span>
                </div>
            </div>
        </div>

        <!-- 내 서재 버튼(메뉴 ON일 때만 표시) -->
        <button class="library-fab" id="libraryFab" type="button" title="내 서재">
            <svg viewBox="0 0 24 24"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></svg>
        </button>
    </div>
</div>

<script>
    // ====== 1920x1080 스테이지 스케일(현재 화면이 더 작으면 축소) ======
    const stage = document.getElementById("stage");
    function fitStage() {
      const sw = 1920, sh = 1080;
      const vw = window.innerWidth, vh = window.innerHeight;
      const scale = Math.min(vw / sw, vh / sh, 1);
      stage.style.transform = `scale(${scale})`;
      stage.style.position = "absolute";
      stage.style.left = `${Math.max(0, (vw - sw * scale) / 2)}px`;
      stage.style.top  = `${Math.max(0, (vh - sh * scale) / 2)}px`;
    }
    window.addEventListener("resize", fitStage);
    fitStage();

    function getScaleFromRect(el) {
      const rect = el.getBoundingClientRect();
      return rect.width / el.offsetWidth; // transform scale 반영
    }

    // ====== epub.js 기본 세팅 ======
    const viewerEl = document.getElementById("viewer");
    let book = null;
    let rendition = null;

    // ====== UI 요소 ======
    const shell = document.getElementById("shell");
    const navLeft = document.getElementById("navLeft");
    const navRight = document.getElementById("navRight");

    const menuTop = document.getElementById("menuTop");
    const menuBottom = document.getElementById("menuBottom");
    const bookTitleEl = document.getElementById("bookTitle");

    const progressRange = document.getElementById("progressRange");
    const pageInput = document.getElementById("pageInput");
    const pageTotalEl = document.getElementById("pageTotal");

    const EDGE = 100;

    // 메뉴 상태: 페이지 이동해도 유지
    let menusOpen = false;
    function setMenusOpen(open) {
      menusOpen = open;
      shell.classList.toggle("menus-open", menusOpen);
    }
    function toggleMenus() { setMenusOpen(!menusOpen); }

    // ====== 스프레드(좌우 합쳐 1페이지) 기준 페이지 계산 ======
    // book.locations (location index) 를 2개씩 묶어서 스프레드 1page로 계산(가벼운 방식)
    let totalSpreads = 1;
    let isScrubbing = false;

    function clamp(n, min, max){ return Math.max(min, Math.min(max, n)); }

    function getCurrentSpreadPage() {
      if (!rendition || !book?.locations) return 1;
      const loc = rendition.currentLocation();
      const startLoc = loc?.start?.location;
      if (typeof startLoc !== "number") return 1;
      return Math.floor(startLoc / 2) + 1;
    }

    function spreadPageToLocationIndex(spreadPage) {
      // spreadPage: 1..totalSpreads  -> location index: 0..book.locations.total-1
      const idx = (spreadPage - 1) * 2;
      return clamp(idx, 0, Math.max(0, (book?.locations?.total || 1) - 1));
    }

    async function ensureLocations() {
      if (!book) return;
      await book.ready;

      // locations 생성(값이 너무 작으면 페이지가 너무 세분화됨. 1600은 무난한 편)
      if (!book.locations || !book.locations.total) {
        await book.locations.generate(1600);
      } else if (!book.locations.total) {
        await book.locations.generate(1600);
      }

      const totalLoc = book.locations.total || 1;
      totalSpreads = Math.max(1, Math.ceil(totalLoc / 2));

      // UI 반영
      progressRange.min = "1";
      progressRange.max = String(totalSpreads);
      pageInput.min = "1";
      pageInput.max = String(totalSpreads);
      pageTotalEl.textContent = String(totalSpreads);

      // 현재 위치 반영
      syncProgressUI();
    }

    function syncProgressUI() {
      const cur = getCurrentSpreadPage();
      if (!isScrubbing) progressRange.value = String(cur);
      pageInput.value = String(cur);
    }

    async function goToSpreadPage(spreadPage) {
      if (!rendition || !book?.locations?.total) return;
      const sp = clamp(Number(spreadPage) || 1, 1, totalSpreads);
      const locIndex = spreadPageToLocationIndex(sp);
      const cfi = book.locations.cfiFromLocation(locIndex);
      if (cfi) await rendition.display(cfi);
    }

    function initRendition() {
      if (!book) return;

      rendition = book.renderTo(viewerEl, {
        width: "100%",
        height: "100%",
        spread: "always",
        flow: "paginated",
        manager: "default"
      });

      rendition.display();

      rendition.themes.default({
        "body": {
          "margin": "0",
          "padding": "48px 64px",
          "line-height": "1.7",
          "color": "#111",
          "background": "#fff"
        }
      });

      // 책 제목 표시(가능하면 metadata에서)
      book.loaded?.metadata?.then(meta => {
        if (meta?.title) bookTitleEl.textContent = meta.title;
      }).catch(()=>{});

      // 렌더될 때마다 iframe 이벤트 바인딩
      rendition.on("rendered", (section, contents) => {
        bindEdgeOverlayForContents(contents);
        bindMenuToggleForContents(contents);
        bindKeyEvents(contents);
        contents.iframe.focus();
      });

      // 페이지가 바뀌면 진행 UI 동기화
      rendition.on("relocated", () => {
        syncProgressUI();
      });

      // 키보드 포커스
      //viewerEl.tabIndex = 0;
      //viewerEl.focus();
      //rendition.focus();

      // locations 준비(진행바/페이지수)
      ensureLocations();
    }

    // ====== 파일 로드(로컬 EPUB) ======
    const btnLoad = document.getElementById("btnLoad");
    const fileInput = document.getElementById("fileInput");
    btnLoad.addEventListener("click", () => fileInput.click());

    fileInput.addEventListener("change", async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;

      // 기존 정리
      if (rendition) {
        try { rendition.destroy(); } catch {}
        rendition = null;
      }
      if (book) {
        try { book.destroy(); } catch {}
        book = null;
      }

      // 메뉴는 기본 숨김으로 시작
      setMenusOpen(false);

      const buf = await file.arrayBuffer();
      book = ePub(buf);
      initRendition();
    });

    // ====== 페이지 이동 ======
    function goPrev() { if (rendition) rendition.prev(); }
    function goNext() { if (rendition) rendition.next(); }

    function bindKeyEvents(contents) {
      contents.document.addEventListener("keydown", (e) => {
        const t = e.target;
        const isTyping = t && (t.tagName === "INPUT" || t.tagName === "TEXTAREA" || t.isContentEditable);
        if (isTyping) return;

        if (e.key === "ArrowLeft") { e.preventDefault(); goPrev(); }
        if (e.key === "ArrowRight") { e.preventDefault(); goNext(); }
      });
    }

    // ====== 오버레이 표시(iframe 내부 mousemove 기준) ======
    function bindEdgeOverlayForContents(contents) {
      const doc = contents.document;
      const iframeEl = contents.iframe;
      if (doc.__edgeBound) return;
      doc.__edgeBound = true;

      function onMove(e) {
        const scale = getScaleFromRect(stage);
        const shellRect = shell.getBoundingClientRect();
        const iframeRect = iframeEl.getBoundingClientRect();

        // iframe 내부 좌표(e.clientX/Y)를 부모 뷰포트 기준으로 변환
        const clientX = (e.clientX * scale) + iframeRect.left;
        const clientY = (e.clientY * scale) + iframeRect.top;

        const inside =
          clientX >= shellRect.left && clientX <= shellRect.right &&
          clientY >= shellRect.top  && clientY <= shellRect.bottom;

        if (!inside) {
          navLeft.classList.remove("show");
          navRight.classList.remove("show");
          return;
        }

        const x = clientX - shellRect.left;
        const inLeft  = x >= 0 && x < (EDGE * scale);
        const inRight = x <= shellRect.width && x > shellRect.width - (EDGE * scale);

        navLeft.classList.toggle("show", inLeft);
        navRight.classList.toggle("show", inRight);

        // 요구사항: 벗어나면 즉시 숨김
        if (!inLeft && !inRight) {
          navLeft.classList.remove("show");
          navRight.classList.remove("show");
        }
      }

      doc.addEventListener("mousemove", onMove, { passive: true });
    }

    // 오버레이 영역 전체 클릭 → 페이지 이동(메뉴 상태 유지)
    navLeft.addEventListener("click", (e) => { e.preventDefault(); goPrev(); });
    navRight.addEventListener("click", (e) => { e.preventDefault(); goNext(); });

    // ====== 책 영역 클릭(좌/우 오버레이 제외) => 상/하단 메뉴 토글 ======
    function bindMenuToggleForContents(contents) {
      const doc = contents.document;
      const iframeEl = contents.iframe;

      if (doc.__menuBound) return;
      doc.__menuBound = true;

      doc.addEventListener("click", (e) => {
        if (!book) return;

        const scale = getScaleFromRect(stage);
        const iframeRect = iframeEl.getBoundingClientRect();
        const clientX = (e.clientX * scale) + iframeRect.left;

        handleMenuToggleByClick(clientX);
      });
    }


    shell.addEventListener("click", (e) => {
      if (book) return;
      handleMenuToggleByClick(e.clientX);
    });

    function handleMenuToggleByClick(clientX) {
      const rect = shell.getBoundingClientRect();
      const x = clientX - rect.left;

      // 좌/우 오버레이 제외
      if (x >= 0 && x < EDGE) return;
      if (x > rect.width - EDGE) return;

      toggleMenus();
    }


    // ====== 진행바: 드래그하는 동안 실시간 이동(스프레드=1페이지), 페이지 단위 ======
    progressRange.addEventListener("input", async () => {
      if (!book?.locations?.total) return;
      isScrubbing = true;
      const target = Number(progressRange.value);
      pageInput.value = String(target);
      await goToSpreadPage(target);
      isScrubbing = false;
    });

    // ====== 페이지 입력: 스프레드 페이지 번호 기준 이동 ======
    function commitPageInput() {
      const v = clamp(Number(pageInput.value) || 1, 1, totalSpreads);
      pageInput.value = String(v);
      progressRange.value = String(v);
      goToSpreadPage(v);
    }

    pageInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        commitPageInput();
        pageInput.blur();
      }
    });
    pageInput.addEventListener("blur", () => {
      commitPageInput();
    });

    // 내 서재 버튼(지금은 패널 미구현: 클릭만 잡아둠)
    document.getElementById("libraryFab").addEventListener("click", () => {
      console.log("내 서재 패널 (추후 구현)");
    });
</script>
</body>
</html>
