<!doctype html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>EPUB Viewer (epub.js)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js"></script>
    <style>
        :root{
          --w: 1600px;
          --h: 900px;
          --page-bg: #ffffff;
          --overlay-w: 100px;

          --menu-h: 72px;
          --menu-gap: 14px;
          --menu-bg: rgba(255,248,238,.58);
          --menu-bd: rgba(255,255,255,.14);
          --menu-txt: rgba(100, 98, 99, .92);
          --menu-muted: rgba(0,0,0,.70);
          --menu-blur: blur(10px);
          --menu-radius: 16px;

          --scrub-h: 10px;

          /* ===== TOC Panel ===== */
          --toc-w: 360px;
          --toc-bg: rgba(255, 248, 238, .92);
          --toc-bd: rgba(0,0,0,.10);
          --toc-shadow: 0 14px 40px rgba(0,0,0,.35);

          /* ===== LIBRARY Panel ===== */
          --lib-w: 520px;
          --lib-max-h: 640px;
          --lib-bg: rgba(255, 248, 238, .94);
          --lib-bd: rgba(0,0,0,.10);
        }

        html, body {
          height: 100%;
          margin: 0;
          background: #fff;
          /*overflow: hidden;*/
          font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif;
        }

        .ebook-main {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 30px 0;
        }

        .stage {
          width: var(--w);
          height: var(--h);
          position: relative;
        }

        .reader-shell {
          position: absolute;
          inset: 24px;
          background: var(--page-bg);
          box-shadow: 0 10px 40px rgba(0,0,0,.55);
          border: 1px solid rgba(0,0,0,.18);
          overflow: hidden;
        }

        #viewer {
          position: absolute;
          inset: 0;
          z-index: 1;
        }

        /* ===== 좌/우 오버레이 ===== */
        .nav-overlay {
          position: absolute;
          top: 0;
          bottom: 0;
          width: var(--overlay-w);
          z-index: 9999;
          pointer-events: auto;
          display: none;
          cursor: pointer;
          user-select: none;
        }
        .nav-overlay.show { display: block; }

        .nav-overlay.e-nav-left {
          left: 0;
          background: linear-gradient(to right, rgba(0,0,0,.28), rgba(0,0,0,0));
        }
        .nav-overlay.e-nav-right {
          right: 0;
          background: linear-gradient(to left, rgba(0,0,0,.28), rgba(0,0,0,0));
        }

        .nav-overlay .arrow {
          position: absolute;
          top: 50%;
          transform: translateY(-50%);
          width: 56px;
          height: 56px;
          border-radius: 999px;
          background: rgba(0,0,0,.32);
          display: grid;
          place-items: center;
          backdrop-filter: blur(6px);
        }
        .nav-overlay.e-nav-left .arrow { left: 18px; }
        .nav-overlay.e-nav-right .arrow { right: 18px; }

        .nav-overlay svg {
          width: 22px;
          height: 22px;
          fill: none;
          stroke: rgba(255,255,255,.92);
          stroke-width: 3;
          stroke-linecap: round;
          stroke-linejoin: round;
        }

        .reader-shell, .nav-overlay { -webkit-user-select: none; user-select: none; }

        .epub-container { z-index: 1; }
        .epub-view { z-index: 2; }
        iframe { position: relative; z-index: 3; }

        /* ===== 다크 모드: 좌/우 오버레이 ===== */
        .reader-shell.theme-dark .nav-overlay.e-nav-left {
          background: linear-gradient(
            to right,
            rgba(255,255,255,.18),
            rgba(255,255,255,0)
          );
        }

        .reader-shell.theme-dark .nav-overlay.e-nav-right {
          background: linear-gradient(
            to left,
            rgba(255,255,255,.18),
            rgba(255,255,255,0)
          );
        }

        .reader-shell.theme-dark .nav-overlay .arrow {
          background: rgba(255,255,255,.22);
        }

        .reader-shell.theme-dark .nav-overlay svg {
          stroke: rgba(255,255,255,.95);
        }


        /* ===== 로더(임시) ===== */
        .loader {
          position: absolute;
          top: 10px;
          left: 10px;
          z-index: 20000;
          display: flex;
          gap: 8px;
          align-items: center;
          padding: 8px 10px;
          border-radius: 10px;
          background: rgba(0,0,0,.55);
          color: #fff;
          font-size: 13px;
          user-select: none;
        }
        .loader button {
          border: 0;
          cursor: pointer;
          padding: 7px 10px;
          border-radius: 8px;
          background: rgba(255,255,255,.14);
          color: #fff;
        }
        .loader button:hover { background: rgba(255,255,255,.22); }
        .loader .hint { opacity: .85; }

        /* ===== 상/하단 메뉴(슬라이드) ===== */
        .menu-top,
        .menu-bottom {
          position: absolute;
          left: 18px;
          right: 18px;
          z-index: 12000;
          border: 1px solid var(--menu-bd);
          background: var(--menu-bg);
          color: var(--menu-txt);
          border-radius: var(--menu-radius);
          backdrop-filter: var(--menu-blur);
          display: flex;
          align-items: center;
          gap: var(--menu-gap);
          padding: 12px 14px;
          box-shadow: 0 10px 30px rgba(0,0,0,.35);
          will-change: transform, opacity;
          transition: transform 220ms ease, opacity 220ms ease;
          opacity: 0;
          pointer-events: none;
        }

        .menu-top {
          top: 18px;
          height: var(--menu-h);
          transform: translateY(-18px);
          justify-content: space-between;
        }
        .menu-bottom {
          bottom: 18px;
          height: var(--menu-h);
          transform: translateY(18px);
          justify-content: space-between;
        }

        .menus-open .menu-top,
        .menus-open .menu-bottom {
          transform: translateY(0);
          opacity: 1;
          pointer-events: auto;
        }


        /*사전 모달*/
        .modal_overlay{
          display: none;
          width: 280px;
          background:rgba(255,248,238);
          border:1px solid rgb(0,0,0);
          border-radius:14px;
          padding:12px;
          box-shadow: 0 8px 20px rgba(0, 0, 0, .06);
          position: fixed;
          text-align: left;
          z-index: 12800;
        }
        .modal_overlay h3{
          margin:0 0 10px 0;
          font-size:13px;
          color:#374151;
          letter-spacing:-.2px;
          display:flex;
          align-items:center;
          justify-content:space-between;
          gap:8px;
        }
        .modal_overlay h3 small{
          font-weight:600;
          color:#9ca3af;
        }

        .dict-card{
          background:#ffffff;
          border:1px solid #e6e1d8;
          border-radius:14px;
          padding:12px;
          box-shadow: 0 6px 16px rgba(0,0,0,.06);
        }
        .dict_modal_head{
          display:flex;
          align-items:flex-start;
          justify-content:space-between;
          gap:10px;
          margin-bottom:8px;
        }
        .headword{
          font-size:24px;
          font-weight:800;
          letter-spacing:-.2px;
          line-height:1.1;
          color: #DCA244;
          margin:0;
        }
        .phon{
          margin-top:4px;
          font-size:12px;
          color:#6b7280;
          display:flex;
          flex-wrap: wrap;
          gap:8px;
          align-items:center;
        }
        .pill{
          font-size:11px;
          padding:3px 8px;
          border-radius:999px;
          border:1px solid rgba(0,0,0,.10);
          background:#fff;
          color:#4b5563;
        }
        .dict-actions{
          display:flex;
          gap:8px;
          align-items:center;
        }
        .icon-mini{
          width:30px; height:30px;
          border-radius:10px;
          border:1px solid rgba(0,0,0,.10);
          background:#fff;
          display:grid;
          place-items:center;
          cursor:pointer;
          transition: transform .08s ease, background .15s ease;
          flex:none;
        }
        .icon-mini:hover{ background:#fffdf7; transform: translateY(-1px); }
        .icon-mini svg{ width:16px; height:16px; opacity:.82; }

        .modal_ul {
          padding: 0;
          list-style-type: none;
        }

        .modal_li{
          margin-top:10px;
          padding-top:10px;
          border-top:1px solid #D9D9D9;
        }
        .modal_li h4{
          margin:0 0 8px 0;
          font-size:12px;
          color:#374151;
          display:flex;
          align-items:center;
          gap:8px;
        }
        .speech{
          font-size:11px;
          padding:2px 7px;
          border-radius:999px;
          background:rgba(243,178,59,.20);
          border:1px solid rgba(243,178,59,.35);
          color:#7a4d00;
        }
        .dict_modal_body{
          margin:0;
          padding-left:16px;
          color:#374151;
          font-size:13px;
          line-height:1.55;
        }
        .dict_modal_body li{ margin:6px 0; }
        .dict-foot{
          margin-top:10px;
          display:flex;
          align-items:center;
          justify-content:space-between;
          gap:10px;
          font-size:11px;
          color:#9ca3af;
        }

        /* ===== Dict loading (buffering) ===== */
        .dict-loading{
          display:flex;
          align-items:center;
          gap:10px;
          padding:10px 0;
          color:#6b7280;
          font-size:12px;
        }
        .dict-spinner{
          width:14px;
          height:14px;
          border-radius:999px;
          border:2px solid rgba(0,0,0,.15);
          border-top-color: rgba(220,162,68,.95);
          animation: dictSpin .8s linear infinite;
        }
        @keyframes dictSpin { to { transform: rotate(360deg); } }

        .dict-skel{
          margin-top:10px;
          display:grid;
          gap:8px;
        }
        .dict-skel-line{
          height:10px;
          border-radius:999px;
          background: linear-gradient(90deg, rgba(0,0,0,.06), rgba(0,0,0,.10), rgba(0,0,0,.06));
          background-size: 200% 100%;
          animation: dictShimmer 1.1s ease-in-out infinite;
        }
        .dict-skel-line.w60{ width:60%; }
        .dict-skel-line.w85{ width:85%; }
        .dict-skel-line.w95{ width:95%; }
        @keyframes dictShimmer { 0%{background-position: 0% 0} 100%{background-position: -200% 0} }

        .dict-error{
          padding:10px 0;
          color:#b91c1c;
          font-size:12px;
        }

        
        /* ===== 보기설정 패널(우상단, 상단 메뉴 아래) ===== */
        .settings-panel{
          position: absolute;
          right: 18px;
          top: calc(18px + var(--menu-h) + 30px);
          z-index: 12500;
          width: 600px;
          max-width: calc(100vw - 36px);
          border-radius: 18px;
          background: rgba(255,248,238,.96);
          border: 1px solid rgba(0,0,0,.10);
          box-shadow: 0 16px 42px rgba(0,0,0,.28);
          overflow: hidden;

          opacity: 0;
          pointer-events: none;
          transform: translateY(-10px);
          transition: transform 220ms ease, opacity 220ms ease;
        }
        .settings-open .settings-panel{
          opacity: 1;
          pointer-events: auto;
          transform: translateY(0);
        }

        .settings-row{
          display: grid;
          grid-template-columns: 140px 1fr;
          align-items: center;
          padding: 16px 18px;
          gap: 12px;
          border-bottom: 2px solid rgba(0,0,0,.10);
          background: transparent;
        }
        .settings-row:last-child{ border-bottom: 0; }

        .settings-label{
          font-size: 22px;
          font-weight: 900;
          color: rgba(0,0,0,.82);
          letter-spacing: -.2px;
          user-select: none;
        }

        /* 테마(동그라미) */
        .theme-dots{
          display: flex;
          align-items: center;
          justify-content: flex-end;
          gap: 22px;
        }
        .theme-dot{
          width: 54px;
          height: 54px;
          border-radius: 999px;
          border: 3px solid rgba(0,0,0,.10);
          cursor: pointer;
          background: #fff;
          box-shadow: 0 10px 22px rgba(0,0,0,.12);
          transition: transform 120ms ease, box-shadow 120ms ease, border-color 120ms ease;
        }
        .theme-dot:hover{ transform: translateY(-1px); }
        .theme-dot.active{
          border-color: rgba(0,0,0,.36);
          box-shadow: 0 14px 28px rgba(0,0,0,.18);
        }
        .theme-dot[data-value="light"]{ background: #ffffff; }
        .theme-dot[data-value="dark"]{ background: #3f4143; }
        .theme-dot[data-value="sepia"]{ background: #efe6cf; }

        /* 글꼴 버튼 */
        .font-pills{
          display: flex;
          justify-content: flex-end;
          gap: 16px;
          flex-wrap: wrap;
        }
        .font-pill{
          min-width: 112px;
          height: 44px;
          padding: 0 16px;
          border-radius: 12px;
          border: 0;
          cursor: pointer;
          background: rgba(134, 188, 156, .80);
          color: rgba(255,255,255,.92);
          font-size: 18px;
          font-weight: 900;
          box-shadow: 0 10px 22px rgba(0,0,0,.14);
          transition: transform 120ms ease, filter 120ms ease, box-shadow 120ms ease;
        }
        .font-pill:hover{ transform: translateY(-1px); filter: brightness(1.02); }

        .font-pill.active {
          background: #8fc7a4;
          color: #ffffff;
          box-shadow:
            inset 0 3px 6px rgba(0,0,0,0.25),
            0 1px 2px rgba(0,0,0,0.15);
          transform: translateY(1px);
          cursor: default;
        }

        .font-pill.gothic {
          font-family: "Apple SD Gothic Neo", "Noto Sans KR", sans-serif;
        }

        .font-pill.batang {
          font-family: "Batang", "바탕", serif;
        }

        .font-pill.myungjo {
          font-family: "Nanum Myeongjo", "명조", serif;
        }

        /* 스텝퍼( -  value  + ) */
        .stepper{
          margin-left: auto;
          width: 240px;
          height: 52px;
          border-radius: 18px;
          background: rgba(209, 156, 64, .92);
          display: grid;
          grid-template-columns: 1fr 1fr 1fr;
          overflow: hidden;
          box-shadow: 0 12px 26px rgba(0,0,0,.16);
          border: 1px solid rgba(0,0,0,.10);
        }
        .stepper > *{
          display: grid;
          place-items: center;
          color: rgba(255,255,255,.96);
          user-select: none;
        }
        .stepper .step-btn{
          border: 0;
          background: transparent;
          cursor: pointer;
          font-size: 32px;
          font-weight: 900;
          line-height: 1;
          width: 100%;
          height: 100%;
          transition: filter 120ms ease, transform 80ms ease;
        }
        .stepper .step-btn:hover{ filter: brightness(1.06); }
        .stepper .step-btn:active{ transform: translateY(1px); }
        .stepper .step-val{
          font-size: 22px;
          font-weight: 900;
          width: 100%;
          height: 100%;
        }
        .stepper .divider{
          position: relative;
        }
        .stepper .divider:before{
          content:"";
          position:absolute;
          left:0;
          top:10px;
          bottom:10px;
          width:2px;
          background: rgba(255,255,255,.28);
        }

        /* 초기화 */
        .settings-reset-row{
          display: flex;
          align-items: center;
          justify-content: center;
          gap: 10px;
          padding: 18px 18px;
          background: transparent;
        }
        .settings-reset{
          border: 0;
          background: transparent;
          cursor: pointer;
          font-size: 22px;
          font-weight: 900;
          color: rgba(0,0,0,.78);
          display: inline-flex;
          align-items: center;
          gap: 10px;
        }
        .settings-reset svg{
          width: 26px;
          height: 26px;
          stroke: rgba(0,0,0,.68);
          fill: none;
          stroke-width: 2.4;
          stroke-linecap: round;
          stroke-linejoin: round;
        }
        .settings-reset:hover{ color: rgba(0,0,0,.92); }

        .book-title {
          font-weight: 700;
          font-size: 16px;
          letter-spacing: .2px;
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
          max-width: 55%;
        }

        .tool-buttons {
          display: flex;
          align-items: center;
          gap: 10px;
          margin-left: auto;
        }

        .icon-btn {
          width: 40px;
          height: 40px;
          border-radius: 12px;
          border: 1px solid rgba(0,0,0,.14);
          background: rgba(0,0,0,.08);
          color: var(--menu-txt);
          display: grid;
          place-items: center;
          cursor: pointer;
          transition: background 120ms ease, transform 120ms ease;
        }
        .icon-btn:hover { background: rgba(0,0,0,.14); transform: translateY(-1px); }
        .icon-btn:active { transform: translateY(0); }

        #dictBtn.active { background: rgba(0,0,0,.14); }

        .icon-btn svg {
          width: 18px;
          height: 18px;
          stroke: rgba(0,0,0,.92);
          fill: none;
          stroke-width: 2.2;
          stroke-linecap: round;
          stroke-linejoin: round;
        }

        /* ===== 하단 진행바 + 페이지 입력 ===== */
        .progress-wrap{
          display: flex;
          align-items: center;
          gap: 12px;
          width: 100%;
        }

        .progress-range{
          -webkit-appearance: none;
          appearance: none;
          width: 100%;
          height: var(--scrub-h);
          border-radius: 999px;
          outline: none;
          background: rgba(255,255,255,.22);
          border: 1px solid rgba(0,0,0,.25);
          cursor: pointer;
        }
        .progress-range::-webkit-slider-thumb{
          -webkit-appearance: none;
          appearance: none;
          width: 18px;
          height: 18px;
          border-radius: 999px;
          background: rgba(255,255,255,.92);
          border: 2px solid rgba(0,0,0,.25);
        }
        .progress-range::-moz-range-thumb{
          width: 18px;
          height: 18px;
          border-radius: 999px;
          background: rgba(255,255,255,.92);
          border: 2px solid rgba(0,0,0,.25);
        }

        .page-num{
          display: flex;
          align-items: center;
          gap: 6px;
          font-size: 13px;
          color: var(--menu-muted);
          flex: 0 0 auto;
        }

        .page-input{
          width: 62px;
          height: 34px;
          border-radius: 10px;
          border: 1px solid rgba(0,0,0,.37);
          background: rgba(255,255,255,1);
          color: var(--menu-txt);
          padding: 0 10px;
          font-size: 13px;
          outline: none;
        }

        /* ===== 내 서재 버튼(메뉴 ON일 때만) ===== */
        .library-fab{
          position: absolute;
          right: 26px;
          bottom: calc(18px + var(--menu-h) + 40px);
          z-index: 13000;
          width: 52px;
          height: 52px;
          border-radius: 18px;
          border: 1px solid rgba(0,0,0,.08);
          background: rgba(255,255,255,.92);
          box-shadow: 0 12px 28px rgba(0,0,0,.25);
          display: grid;
          place-items: center;
          cursor: pointer;
          transition: transform 120ms ease, opacity 200ms ease;
          opacity: 0;
          pointer-events: none;
        }
        .library-fab svg{
          width: 20px;
          height: 20px;
          stroke: rgba(0,0,0,.78);
          fill: none;
          stroke-width: 2.2;
          stroke-linecap: round;
          stroke-linejoin: round;
        }
        .menus-open .library-fab{
          opacity: 1;
          pointer-events: auto;
        }
        .library-fab:hover{ transform: translateY(-1px); }
        .library-fab:active{ transform: translateY(0); }

        /* ===== 내 서재 패널 ===== */
        .library-panel{
          position: absolute;
          right: 18px;
          bottom: calc(18px + var(--menu-h) + 40px + 56px); /* FAB 위로 */
          width: var(--lib-w);
          max-height: var(--lib-max-h);
          z-index: 13600;

          border-radius: 18px;
          border: 1px solid var(--lib-bd);
          background: var(--lib-bg);
          box-shadow: 0 16px 44px rgba(0,0,0,.36);
          backdrop-filter: blur(10px);
          overflow: hidden;

          /* 버튼에서 확장되는 느낌 */
          transform-origin: bottom right;
          transform: scale(.92) translateY(10px);
          opacity: 0;
          pointer-events: none;
          transition: transform 180ms ease, opacity 180ms ease;

          display: flex;
          flex-direction: column;
        }

        /* 열림 상태(나중에 JS에서 shell에 클래스 붙일 예정) */
        .library-open .library-panel{
          transform: scale(1) translateY(0);
          opacity: 1;
          pointer-events: auto;
        }

        .library-header{
          display: flex;
          align-items: center;
          justify-content: space-between;
          padding: 14px 14px;
          border-bottom: 1px solid rgba(0,0,0,.08);
        }

        .library-title{
          font-weight: 800;
          letter-spacing: -.2px;
          color: rgba(40,40,40,.92);
        }

        .library-close{
          width: 36px;
          height: 36px;
          border-radius: 12px;
          border: 1px solid rgba(0,0,0,.10);
          background: rgba(255,255,255,.70);
          display: grid;
          place-items: center;
          cursor: pointer;
        }
        .library-close:hover{ background: rgba(255,255,255,.86); }
        .library-close svg{
          width: 18px;
          height: 18px;
          fill: none;
          stroke: rgba(0,0,0,.72);
          stroke-width: 2.4;
          stroke-linecap: round;
          stroke-linejoin: round;
        }

        .library-body{
          padding: 12px 12px 14px;
          overflow: auto;
        }

        .library-grid{
          display: grid;
          grid-template-columns: 1fr 1fr;
          gap: 12px;
        }

        .book-card{
          border: 1px solid rgba(0,0,0,.08);
          background: rgba(255,255,255,.78);
          border-radius: 16px;
          padding: 10px;
          cursor: pointer;
          text-align: left;
          display: grid;
          grid-template-columns: 82px 1fr;
          gap: 10px;
          box-shadow: 0 10px 22px rgba(0,0,0,.12);
          transition: transform 120ms ease, box-shadow 120ms ease;
        }
        .book-card:hover{
          transform: translateY(-1px);
          box-shadow: 0 14px 26px rgba(0,0,0,.18);
        }
        .book-card:active{ transform: translateY(0); }

        .cover-wrap{
          position: relative;
          width: 82px;
          height: 112px;
          border-radius: 12px;
          overflow: hidden;
          background: rgba(0,0,0,.06);
          border: 1px solid rgba(0,0,0,.06);
        }
        .book-cover{
          width: 100%;
          height: 100%;
          object-fit: cover;
          display: block;
        }

        .badge-ebook{
          position: absolute;
          right: 8px;
          bottom: 8px;
          width: 22px;
          height: 22px;
          border-radius: 8px;
          display: grid;
          place-items: center;
          font-size: 12px;
          font-weight: 900;
          letter-spacing: -.2px;

          background: rgba(0,0,0,.70);
          color: rgba(255,255,255,.95);
          border: 1px solid rgba(255,255,255,.18);
          backdrop-filter: blur(6px);
        }

        .book-meta{
          min-width: 0;
          display: flex;
          flex-direction: column;
          gap: 6px;
          padding-top: 2px;
        }

        .book-title{
          font-size: 13px;
          font-weight: 900;
          color: rgba(20,20,20,.92);
          overflow: hidden;
          white-space: nowrap;
          text-overflow: ellipsis;
        }

        .book-author{
          font-size: 12px;
          color: rgba(0,0,0,.62);
          overflow: hidden;
          white-space: nowrap;
          text-overflow: ellipsis;
        }

        .progress-row{
          margin-top: auto;
          display: flex;
          align-items: center;
          gap: 8px;
        }

        .progress-track{
          flex: 1;
          height: 8px;
          border-radius: 999px;
          background: rgba(0,0,0,.10);
          overflow: hidden;
        }
        .progress-fill{
          height: 100%;
          border-radius: 999px;
          background: rgba(0,0,0,.56);
        }

        .library-footer{
          padding: 10px 14px 12px;
          border-top: 1px solid rgba(0,0,0,.08);
        }
        .library-hint{
          font-size: 12px;
          color: rgba(0,0,0,.55);
        }

        /* 좁은 화면에서 1열로 */
        @media (max-width: 720px){
          .library-panel{ width: 92vw; right: 12px; }
          .library-grid{ grid-template-columns: 1fr; }
        }

        /* =========================
           TOC Panel (Right slide)
           ========================= */
        .toc-backdrop{
          position: absolute;
          inset: 0;
          z-index: 13400;
          background: rgba(0,0,0,.18);
          opacity: 0;
          pointer-events: none;
          transition: opacity 180ms ease;
        }
        .toc-panel{
          position: absolute;
          top: 18px;
          right: 18px;
          bottom: 18px;
          width: var(--toc-w);
          z-index: 13500;
          border-radius: 18px;
          border: 1px solid var(--toc-bd);
          background: var(--toc-bg);
          box-shadow: var(--toc-shadow);
          backdrop-filter: blur(10px);
          overflow: hidden;

          transform: translateX(calc(var(--toc-w) + 26px));
          opacity: 0;
          pointer-events: none;
          transition: transform 220ms ease, opacity 220ms ease;
          display: flex;
          flex-direction: column;
        }

        .toc-open .toc-backdrop{
          opacity: 1;
          pointer-events: auto;
        }
        .toc-open .toc-panel{
          transform: translateX(0);
          opacity: 1;
          pointer-events: auto;
        }

        .toc-header{
          display: flex;
          align-items: center;
          justify-content: space-between;
          padding: 14px 14px;
          border-bottom: 1px solid rgba(0,0,0,.08);
        }
        .toc-title{
          font-weight: 800;
          font-size: 15px;
          color: rgba(0,0,0,.82);
          letter-spacing: .2px;
        }
        .toc-close{
          width: 36px;
          height: 36px;
          border-radius: 12px;
          border: 1px solid rgba(0,0,0,.12);
          background: rgba(0,0,0,.06);
          cursor: pointer;
          display: grid;
          place-items: center;
        }
        .toc-close:hover{ background: rgba(0,0,0,.10); }
        .toc-close svg{
          width: 18px;
          height: 18px;
          stroke: rgba(0,0,0,.85);
          fill: none;
          stroke-width: 2.4;
          stroke-linecap: round;
          stroke-linejoin: round;
        }

        .toc-body{
          flex: 1;
          overflow: auto;
          padding: 10px 8px 12px 8px;
        }

        .toc-empty{
          margin: 14px 10px;
          padding: 12px 12px;
          border-radius: 14px;
          border: 1px dashed rgba(0,0,0,.18);
          background: rgba(255,255,255,.55);
          color: rgba(0,0,0,.70);
          font-size: 13px;
          line-height: 1.4;
        }

        .toc-list{
          list-style: none;
          margin: 0;
          padding: 0;
        }
        .toc-item{
          margin: 2px 0;
        }
        .toc-link{
          width: 100%;
          text-align: left;
          border: 0;
          background: transparent;
          cursor: pointer;
          padding: 9px 10px;
          border-radius: 12px;
          color: rgba(0,0,0,.82);
          font-size: 13px;
          line-height: 1.25;
          display: block;
          transition: background 120ms ease;
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
        }
        .toc-link:hover{
          background: rgba(0,0,0,.06);
        }
        .toc-link.active{
          background: rgba(0,0,0,.12);
          font-weight: 800;
        }
        .toc-link .label{
          display: inline-block;
          vertical-align: middle;
        }
        .toc-indent-0 .toc-link{ padding-left: 10px; }
        .toc-indent-1 .toc-link{ padding-left: 24px; }
        .toc-indent-2 .toc-link{ padding-left: 38px; }
        .toc-indent-3 .toc-link{ padding-left: 52px; }
        .toc-indent-4 .toc-link{ padding-left: 66px; }
        .toc-indent-5 .toc-link{ padding-left: 80px; }

        /* ===== Book Loading Overlay ===== */
        .book-loading{
          position: absolute;
          inset: 0;
          z-index: 20000;
          background: rgba(255, 248, 238, 0.92);
          display: none;
          align-items: center;
          justify-content: center;
          backdrop-filter: blur(6px);
        }

        .book-loading.show{
          display: flex;
        }

        .loading-box{
          display: flex;
          flex-direction: column;
          align-items: center;
          gap: 14px;
          color: #7a4d00;
          font-weight: 700;
        }

        .loading-box p{
          margin: 0;
          font-size: 14px;
          letter-spacing: -0.2px;
        }

        .spinner{
          width: 42px;
          height: 42px;
          border-radius: 50%;
          border: 4px solid rgba(0,0,0,0.15);
          border-top-color: #DCA244;
          animation: spin 0.9s linear infinite;
        }

        @keyframes spin{
          to { transform: rotate(360deg); }
        }

    </style>
    <link rel="stylesheet" th:href="@{/css/footer.css}">
</head>
<body>
<!--
<div class="loader">
    <h2>1</h2>
    <button id="btnLoad">EPUB 불러오기</button>
    <span class="hint">←/→ · 가장자리(100px) · 책 클릭 메뉴</span>
    <input id="fileInput" type="file" accept=".epub,application/epub+zip" hidden />
</div>
-->
<div th:replace="fragments/header :: header"></div>

<main class="ebook-main" style="text-align:center">
<div class="stage" id="stage">
    <div class="reader-shell" id="shell">
        <div id="viewer"></div>

        <!-- ===== EPUB 로딩 오버레이 ===== -->
        <div id="bookLoading" class="book-loading">
            <div class="loading-box">
                <div class="spinner"></div>
                <p>책을 불러오는 중입니다…</p>
            </div>
        </div>

        <!-- 좌/우 그라데이션 + 화살표 오버레이 -->
        <div class="nav-overlay e-nav-left" id="navLeft" aria-label="Previous page">
            <div class="arrow" aria-hidden="true">
                <svg viewBox="0 0 24 24"><path d="M15 18l-6-6 6-6"></path></svg>
            </div>
        </div>

        <div class="nav-overlay e-nav-right" id="navRight" aria-label="Next page">
            <div class="arrow" aria-hidden="true">
                <svg viewBox="0 0 24 24"><path d="M9 6l6 6-6 6"></path></svg>
            </div>
        </div>

        <!-- 상단 메뉴 -->
        <div class="menu-top" id="menuTop">
            <div class="book-title" id="bookTitle"></div>
            <div class="tool-buttons">
                <button class="icon-btn" id="dictBtn" title="사전" type="button">
                    <svg viewBox="0 0 24 24"><path d="M4 6h10a4 4 0 0 1 4 4v11H8a4 4 0 0 0-4 4z"/><path d="M8 6v15"/></svg>
                </button>
                <!--
                <button class="icon-btn" title="TTS" type="button">
                    <svg viewBox="0 0 24 24"><path d="M11 5H7a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h4"/><path d="M15 8a3 3 0 0 1 0 8"/><path d="M17.5 5.5a6 6 0 0 1 0 13"/></svg>
                </button>
                -->
                <button class="icon-btn" id="viewSettingBtn" title="보기설정" type="button">
                    <svg viewBox="0 0 24 24"><path d="M12 3v3"/><path d="M12 18v3"/><path d="M4.22 4.22l2.12 2.12"/><path d="M17.66 17.66l2.12 2.12"/><path d="M3 12h3"/><path d="M18 12h3"/><path d="M4.22 19.78l2.12-2.12"/><path d="M17.66 6.34l2.12-2.12"/><path d="M12 8a4 4 0 1 0 0 8a4 4 0 0 0 0-8z"/></svg>
                </button>
                <!-- 목차 버튼에 id 추가 -->
                <button class="icon-btn" id="tocBtn" title="목차" type="button">
                    <svg viewBox="0 0 24 24"><path d="M8 6h13"/><path d="M8 12h13"/><path d="M8 18h13"/><path d="M3 6h.01"/><path d="M3 12h.01"/><path d="M3 18h.01"/></svg>
                </button>
            </div>
        </div>

        <!-- 사전 모달 -->
        <div id="dict_modal_overlay" class="modal_overlay">
            <h3>사전 <small>Dictionary</small></h3>

            <div class="dict-card">
                <div class="dict_modal_head">
                    <div>
                        <p class="headword">단어</p>
                        <div class="phon">
                            <!-- 발음 -->
                        </div>
                    </div>
                    <div class="dict-actions">
                        <button onclick="playPronunciation()" class="icon-mini phonetic_mp3_btn" title="발음 듣기">
                            <svg viewBox="0 0 24 24" fill="none"><path d="M11 5 6 9H3v6h3l5 4V5Z" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/><path d="M16 9a4 4 0 0 1 0 6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
                        </button>
                        <button onclick="closeModal()" class="icon-mini dict_modal_close" title="닫기(예시)">
                            <svg viewBox="0 0 24 24" fill="none"><path d="M6 6l12 12M18 6 6 18" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
                        </button>
                    </div>
                </div>

                <ul class="modal_ul">
                    <li class="modal_li">
                        <h4><span class="speech"></span></h4>
                        <ol class="dict_modal_body">
                            <li>단어뜻</li>
                            <li>단어뜻</li>
                        </ol>
                    </li>
                </ul>
                <div class="dict-foot">
                    <span>예문/추가 정보 영역(구성 유지)</span>
                    <span class="dict_license">CC BY-SA 3.0</span>
                </div>
            </div>
        </div>

        
        <!-- 보기설정 패널(상단 메뉴 아래, 우상단) -->
        <div class="settings-panel" id="settingsPanel" aria-label="보기설정">
            <div class="settings-row">
                <div class="settings-label">배경</div>
                <div class="theme-dots" data-group="theme">
                    <button class="theme-dot" type="button" data-value="light" aria-label="라이트 테마"></button>
                    <button class="theme-dot" type="button" data-value="dark" aria-label="다크 테마"></button>
                    <button class="theme-dot" type="button" data-value="sepia" aria-label="세피아 테마"></button>
                </div>
            </div>

            <div class="settings-row">
                <div class="settings-label">글꼴</div>
                <div class="font-pills" data-group="font">
                    <button class="font-pill gothic" type="button" data-value="gothic">고딕체</button>
                    <button class="font-pill batang" type="button" data-value="batang">바탕체</button>
                    <button class="font-pill myungjo" type="button" data-value="myeongjo">명조체</button>
                </div>
            </div>

            <div class="settings-row">
                <div class="settings-label">글자 크기</div>
                <div class="stepper" data-group="size">
                    <button class="step-btn" type="button" data-action="dec" aria-label="글자 크기 감소">−</button>
                    <div class="step-val divider" id="valSize">3</div>
                    <button class="step-btn divider" type="button" data-action="inc" aria-label="글자 크기 증가">+</button>
                </div>
            </div>

            <div class="settings-row">
                <div class="settings-label">글자 간격</div>
                <div class="stepper" data-group="letter">
                    <button class="step-btn" type="button" data-action="dec" aria-label="글자 간격 감소">−</button>
                    <div class="step-val divider" id="valLetter">3</div>
                    <button class="step-btn divider" type="button" data-action="inc" aria-label="글자 간격 증가">+</button>
                </div>
            </div>

            <div class="settings-row">
                <div class="settings-label">줄 간격</div>
                <div class="stepper" data-group="line">
                    <button class="step-btn" type="button" data-action="dec" aria-label="줄 간격 감소">−</button>
                    <div class="step-val divider" id="valLine">3</div>
                    <button class="step-btn divider" type="button" data-action="inc" aria-label="줄 간격 증가">+</button>
                </div>
            </div>

            <div class="settings-reset-row">
                <button class="settings-reset" id="settingsReset" type="button" aria-label="설정 초기화">
                    설정 초기화
                    <svg viewBox="0 0 24 24" aria-hidden="true">
                      <path d="M21 12a9 9 0 1 1-3-6.7"/><path d="M21 3v7h-7"/>
                    </svg>
                </button>
            </div>
        </div>

        <!-- 하단 메뉴 -->
        <div class="menu-bottom" id="menuBottom">
            <div class="progress-wrap">
                <input id="progressRange" class="progress-range" type="range" min="1" max="1" value="1" step="1" />
                <div class="page-num">
                    <input id="pageInput" class="page-input" type="number" min="1" value="1" />
                    <span>/</span>
                    <span id="pageTotal">1</span>
                </div>
            </div>
        </div>

        <!-- 내 서재 버튼(메뉴 ON일 때만 표시) -->
        <button class="library-fab" id="libraryFab" type="button" title="내 서재">
            <svg viewBox="0 0 24 24"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></svg>
        </button>

        <!-- ===== 내 서재 패널 (FAB에서 확장) ===== -->
        <aside class="library-panel" id="libraryPanel" aria-label="내 전자책" tabindex="-1">
            <div class="library-header">
                <div class="library-title">내 전자책</div>

                <button class="library-close" id="libraryClose" type="button" aria-label="내 서재 닫기" title="닫기">
                    <svg viewBox="0 0 24 24" aria-hidden="true">
                        <path d="M18 6L6 18"></path>
                        <path d="M6 6l12 12"></path>
                    </svg>
                </button>
            </div>

            <div class="library-body">
                <div class="library-grid" id="libraryGrid">
                    <!-- JS 렌더링 영역 -->
                </div>
            </div>

            <div class="library-footer">
                <div class="library-hint">전자책은 E 표시로 구분돼요.</div>
            </div>
        </aside>


        <!-- ===== TOC Backdrop + Panel ===== -->
        <div class="toc-backdrop" id="tocBackdrop" aria-hidden="true"></div>

        <aside class="toc-panel" id="tocPanel" aria-label="목차 패널" tabindex="-1">
            <div class="toc-header">
                <div class="toc-title">목차</div>
                <button class="toc-close" id="tocClose" type="button" aria-label="목차 닫기" title="닫기">
                    <svg viewBox="0 0 24 24"><path d="M18 6L6 18"/><path d="M6 6l12 12"/></svg>
                </button>
            </div>
            <div class="toc-body" id="tocBody">
                <!-- 동적 렌더링 -->
            </div>
        </aside>
    </div>
</div>
</main>

<!-- ================= 푸터 ================= -->
<div th:replace="fragments/footer :: footer"></div>

<script th:inline="javascript">
    const MY_EBOOK_ISBN = [[${isbn}]];
    const MY_EBOOK_LIST = [[${myEbookList}]];
    const LAST_CFI = [[${lastCfi}]];
    const LAST_PCT = [[${lastPct}]];
    const LAST_HREF = [[${lastHref}]];
</script>

<script>
    // ====== 1920x1080 스테이지 스케일(현재 화면이 더 작으면 축소) ======
    const stage = document.getElementById("stage");
    function fitStage() {
      const sw = 1600, sh = 900;
      const vw = window.innerWidth, vh = window.innerHeight;
      const scale = Math.min(vw / sw, vh / sh, 1);
      //stage.style.transform = `scale(${scale}) translate(-50%)`;
      stage.style.transform = `scale(${scale})`;
      //stage.style.position = "absolute";
      console.log(vw);
      console.log(sw);
      //stage.style.left = `${Math.max(0, (vw - sw * scale) / 2)}px`;
      //stage.style.left = `50%`;
      //stage.style.top  = `${Math.max(0, (vh - sh * scale) / 2)}px`;
    }
    window.addEventListener("resize", fitStage);
    fitStage();

    function getScaleFromRect(el) {
      const rect = el.getBoundingClientRect();
      return rect.width / el.offsetWidth;
    }

    // ====== 로딩 제어용 ======
    const bookLoadingEl = document.getElementById("bookLoading");
    let firstRendered = false;

    function showBookLoading(){
      bookLoadingEl.classList.add("show");
    }
    function hideBookLoading(){
      bookLoadingEl.classList.remove("show");
    }

    // ====== epub.js 기본 세팅 ======
    const viewerEl = document.getElementById("viewer");
    let book = null;
    let rendition = null;

    // ====== UI 요소 ======
    const shell = document.getElementById("shell");
    const navLeft = document.getElementById("navLeft");
    const navRight = document.getElementById("navRight");

    const menuTop = document.getElementById("menuTop");
    const menuBottom = document.getElementById("menuBottom");
    const bookTitleEl = document.getElementById("bookTitle");

    const progressRange = document.getElementById("progressRange");
    const pageInput = document.getElementById("pageInput");
    const pageTotalEl = document.getElementById("pageTotal");

    const EDGE = 100;

    // ====== 메뉴 상태: 페이지 이동해도 유지 ======
    let menusOpen = false;
    function setMenusOpen(open) {
      menusOpen = open;
      shell.classList.toggle("menus-open", menusOpen);

      // 상/하단 메뉴가 꺼질 때, 보기설정 패널도 같이 닫기
      if (!menusOpen && typeof settingsOpen !== "undefined" && settingsOpen) {
        setSettingsOpen(false);
      }
    }
    function toggleMenus() { setMenusOpen(!menusOpen); }

    // ====== TOC 상태 ======
    const tocBtn = document.getElementById("tocBtn");
    const tocPanel = document.getElementById("tocPanel");
    const tocBackdrop = document.getElementById("tocBackdrop");
    const tocClose = document.getElementById("tocClose");
    const tocBody = document.getElementById("tocBody");

    let tocOpen = false;

    // TOC 렌더/매핑용
    let tocFlat = []; // { file, frag, el, cfi }
    let tocLastActiveEl = null;

    function setTocOpen(open) {
      tocOpen = open;
      shell.classList.toggle("toc-open", tocOpen);

      if (tocOpen) {
        // 목차를 열면 메뉴도 같이 열어두는 UX
        setMenusOpen(true);

        // 패널 포커스(키 이벤트를 뺏는 용도가 아니라, 접근성/안정 목적)
        requestAnimationFrame(() => tocPanel.focus({ preventScroll: true }));

        // 열릴 때 현재 위치 하이라이트/스크롤
        syncTocActive();
      }
    }
    function toggleToc() { setTocOpen(!tocOpen); }

    tocBtn.addEventListener("click", () => {
      if (!book) return;
      toggleToc();
    });
    tocClose.addEventListener("click", () => setTocOpen(false));
    tocBackdrop.addEventListener("click", () => setTocOpen(false));

    // ESC로 닫기
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        e.preventDefault();

        if (tocOpen) setTocOpen(false);
        if (settingsOpen) setSettingsOpen(false);
        if (libraryOpen) closeLibrary();
      }
    });

    // ====== 보기설정(UI + 적용 + 저장) ======
    const viewSettingBtn = document.getElementById("viewSettingBtn");
    const settingsPanel = document.getElementById("settingsPanel");
    const settingsReset = document.getElementById("settingsReset");

    const SETTINGS_KEY = "epubViewer.settings.v1";
    const DEFAULT_SETTINGS = {
      theme: "light",   // light | dark | sepia
      font: "gothic",   // gothic | batang | myeongjo
      size: 3,          // 1..5
      letter: 3,        // 1..5
      line: 3           // 1..5
    };

    let settingsOpen = false;
    function setSettingsOpen(open){
      settingsOpen = open;
      shell.classList.toggle("settings-open", settingsOpen);
      if (settingsOpen) {
        // 설정을 열면 메뉴도 열어두는 UX
        setMenusOpen(true);
        // 목차가 열려 있으면 겹치지 않게 닫아둠
        if (tocOpen) setTocOpen(false);
      }
    }
    function toggleSettings(){ setSettingsOpen(!settingsOpen); }

    function clampStep(v){
      const n = Number(v);
      if (!Number.isFinite(n)) return 3;
      return Math.max(1, Math.min(5, Math.round(n)));
    }

    function normalizeSettings(raw){
      const s = { ...DEFAULT_SETTINGS, ...(raw || {}) };
      if (!(["light","dark","sepia"].includes(s.theme))) s.theme = DEFAULT_SETTINGS.theme;
      if (!(["gothic","batang","myeongjo"].includes(s.font))) s.font = DEFAULT_SETTINGS.font;
      s.size = clampStep(s.size);
      s.letter = clampStep(s.letter);
      s.line = clampStep(s.line);
      return s;
    }

    function loadSettings(){
      try {
        const raw = JSON.parse(localStorage.getItem(SETTINGS_KEY) || "null");
        return normalizeSettings(raw);
      } catch {
        return { ...DEFAULT_SETTINGS };
      }
    }

    function saveSettings(s){
      try { localStorage.setItem(SETTINGS_KEY, JSON.stringify(normalizeSettings(s))); } catch {}
    }

    function mapSettingsToCss(s){
      // 단계(1~5) 매핑
      const fontSizePct = [90, 100, 110, 120, 135][s.size - 1];
      const letterEm = [0, 0.02, 0.04, 0.06, 0.08][s.letter - 1];
      const lineH = [1.3, 1.45, 1.6, 1.75, 1.9][s.line - 1];

      const fonts = {
        gothic: 'system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif',
        batang: '"Batang", "바탕", "Noto Serif KR", serif',
        myeongjo: '"Nanum Myeongjo", "명조", "Noto Serif KR", serif'
      };

      const themes = {
        light: { bg: "#ffffff", fg: "#111111" },
        dark:  { bg: "#111214", fg: "#f2f3f5" },
        sepia: { bg: "#f4ecd8", fg: "#2a241d" }
      };

      const th = themes[s.theme] || themes.light;
      return { fontSizePct, letterEm, lineH, fontFamily: fonts[s.font] || fonts.gothic, bg: th.bg, fg: th.fg };
    }

    function applySettingsToContents(contents, s){
      if (!contents?.document) return;
      const css = mapSettingsToCss(s);
      const doc = contents.document;

      // 스타일 태그 1개만 유지
      const STYLE_ID = "__epub_viewer_settings_style__";
      let styleEl = doc.getElementById(STYLE_ID);
      if (!styleEl) {
        styleEl = doc.createElement("style");
        styleEl.id = STYLE_ID;
        doc.head.appendChild(styleEl);
      }

      styleEl.textContent = `
        html, body {
          background: ${css.bg} !important;
          color: ${css.fg} !important;
          font-family: ${css.fontFamily} !important;
          font-size: ${css.fontSizePct}% !important;
          letter-spacing: ${css.letterEm}em !important;
          line-height: ${css.lineH} !important;
        }
        /* 일부 책은 컨테이너에 색/배경을 박아두기도 해서 한 번 더 */
        body * { color: inherit; }
      `;
    }

    function applyThemeClass(theme) {
      shell.classList.remove("theme-light", "theme-dark", "theme-sepia");
      shell.classList.add(`theme-${theme}`);
    }

    function applySettingsToAllContents(s){
      if (!rendition) return;
      try {
        rendition.getContents().forEach((c) => applySettingsToContents(c, s));
      } catch {}
    }

    
    function updateSettingsUi(s){
      // theme dots
      settingsPanel.querySelectorAll('.theme-dot').forEach((btn)=>{
        btn.classList.toggle('active', btn.dataset.value === s.theme);
      });

      // font pills
      settingsPanel.querySelectorAll('.font-pill').forEach((btn)=>{
        btn.classList.toggle('active', btn.dataset.value === s.font);
      });

      // step values
      const elSize = document.getElementById('valSize');
      const elLetter = document.getElementById('valLetter');
      const elLine = document.getElementById('valLine');
      if (elSize) elSize.textContent = String(s.size);
      if (elLetter) elLetter.textContent = String(s.letter);
      if (elLine) elLine.textContent = String(s.line);
    }

    function setSetting(group, value){
      const s = loadSettings();
      if (group === "theme") s.theme = String(value);
      if (group === "font") s.font = String(value);
      if (group === "size") s.size = clampStep(value);
      if (group === "letter") s.letter = clampStep(value);
      if (group === "line") s.line = clampStep(value);
      const norm = normalizeSettings(s);
      saveSettings(norm);
      updateSettingsUi(norm);
      applySettingsToAllContents(norm);
      applyThemeClass(norm.theme);
    }

    // UI 바인딩
    viewSettingBtn?.addEventListener("click", () => {
      if (!book) return;
      if (!settingsOpen) {
        const s = loadSettings();
        updateSettingsUi(s);
        applySettingsToAllContents(s);
      }
      toggleSettings();
      refocusViewer();
    });

    settingsPanel?.addEventListener("click", (e) => {
      // Theme
      const themeBtn = e.target?.closest?.("button.theme-dot");
      if (themeBtn) {
        setSetting("theme", themeBtn.dataset.value);
        refocusViewer();
        return;
      }

      // Font
      const fontBtn = e.target?.closest?.("button.font-pill");
      if (fontBtn) {
        setSetting("font", fontBtn.dataset.value);
        refocusViewer();
        return;
      }

      // Stepper
      const stepBtn = e.target?.closest?.("button.step-btn");
      if (stepBtn) {
        const stepper = stepBtn.closest(".stepper");
        const group = stepper?.dataset?.group;
        const action = stepBtn.dataset.action;
        if (!group || !action) return;

        const s = loadSettings();
        const delta = action === "inc" ? 1 : -1;
        if (group === "size") s.size = clampStep(s.size + delta);
        if (group === "letter") s.letter = clampStep(s.letter + delta);
        if (group === "line") s.line = clampStep(s.line + delta);

        const norm = normalizeSettings(s);
        saveSettings(norm);
        updateSettingsUi(norm);
        applySettingsToAllContents(norm);
        refocusViewer();
      }
    });

    settingsReset?.addEventListener("click", () => {
      saveSettings(DEFAULT_SETTINGS);
      updateSettingsUi(DEFAULT_SETTINGS);
      applySettingsToAllContents(DEFAULT_SETTINGS);
      refocusViewer();
    });

    // ====== 스프레드(좌우 합쳐 1페이지) 기준 페이지 계산 ======
    let totalSpreads = 1;
    let isScrubbing = false;

    function clamp(n, min, max){ return Math.max(min, Math.min(max, n)); }

    function getCurrentSpreadPage() {
      if (!rendition || !rendition.currentLocation) return 1;
      const loc = rendition.currentLocation();
      const startLoc = loc?.start?.location;
      if (typeof startLoc !== "number") return 1;
      return Math.floor(startLoc / 2) + 1;
    }

    function spreadPageToLocationIndex(spreadPage) {
      const idx = (spreadPage - 1) * 2;
      return clamp(idx, 0, Math.max(0, (book?.locations?.total || 1) - 1));
    }

    async function ensureLocations() {
      if (!book) return;
      await book.ready;

      if (!book.locations || !book.locations.total) {
        await book.locations.generate(1600);
      } else if (!book.locations.total) {
        await book.locations.generate(1600);
      }

      //localStorage.removeItem(`epub-locations:${MY_EBOOK_ISBN}`);

      const totalLoc = book.locations.total || 1;
      totalSpreads = Math.max(1, Math.ceil(totalLoc / 2));

      progressRange.min = "1";
      progressRange.max = String(totalSpreads);
      pageInput.min = "1";
      pageInput.max = String(totalSpreads);
      pageTotalEl.textContent = String(totalSpreads);

      syncProgressUI();
    }

    function syncProgressUI() {
      if (!rendition || !book?.locations) return;
      const cur = getCurrentSpreadPage();
      if (!isScrubbing) progressRange.value = String(cur);
      pageInput.value = String(cur);
    }

    async function goToSpreadPage(spreadPage) {
      if (!rendition || !book?.locations?.total) return;
      const sp = clamp(Number(spreadPage) || 1, 1, totalSpreads);
      const locIndex = spreadPageToLocationIndex(sp);
      const cfi = book.locations.cfiFromLocation(locIndex);
      if (cfi) await rendition.display(cfi);
    }

    // ====== TOC 유틸 ======
    function hydrateTocCfi(section, contents){
      const doc = contents.document;
      //const secHref = (section?.href || "").replace(/\\/g,"/");
      const secFile = normalizeFileHref(section?.href || "");

      for(const it of tocFlat){
        if(it.cfi) continue;
        if(it.fileNorm !== secFile) continue;
        if(!it.frag){
          try { it.cfi = section?.cfiBase || null; } catch {}
          continue;
        }

        const target = doc.getElementById(it.frag);
        if(!target) continue;

        try {
          it.targetEl = target;
          it.cfi = section.cfiFromElement(target);
        } catch(e) {
          console.error("section.cfiFromElement error:", e);
        }

        if (!it.cfi) {
          try {
            const r = doc.createRange();
            r.selectNode(target);
            it.cfi = section.cfiFromRange(r);
          } catch (e) {
            console.error("section.cfiFromRange error:", e);
          }
        }
      }

      // 같은 파일 항목들은 문서 순서대로 정렬(중요)
      try{
        const tool = new ePub.CFI();
        tocFlat.sort((x,y)=>{
          if(!x.cfi && !y.cfi) return 0;
          if(!x.cfi) return 1;
          if(!y.cfi) return -1;
          return tool.compare(x.cfi, y.cfi);
        });
      } catch {}
    }

    function normalizeFileHref(href) {
      if (!href) return "";
      const noFrag = String(href).split("#")[0];
      const noQuery = noFrag.split("?")[0];
      return decodeURIComponent(noQuery.trim().replace(/\\/g, "/")).replace(/^\/+/, "");
    }
    function getFrag(href) {
      if (!href) return "";
      const parts = String(href).split("#");
      return parts.length > 1 ? parts[1] : "";
    }

    function safeLabel(item) {
      return (item?.label || item?.title || item?.name || "Untitled").toString();
    }

    function clearTocActive() {
      if (tocLastActiveEl) tocLastActiveEl.classList.remove("active");
      tocLastActiveEl = null;
    }

    function setTocActiveEl(el, doScroll) {
      if (!el) return;
      if (tocLastActiveEl && tocLastActiveEl !== el) tocLastActiveEl.classList.remove("active");
      el.classList.add("active");
      tocLastActiveEl = el;

      if (doScroll && tocOpen) {
        // 패널 내에서만 스크롤되도록(overflow auto 컨테이너)
        requestAnimationFrame(() => {
          try {
            el.scrollIntoView({ block: "center", behavior: "smooth" });
          } catch {
            // 구형 브라우저 fallback
            const container = document.getElementById("tocBody");
            const top = el.offsetTop - 80;
            container.scrollTop = Math.max(0, top);
          }
        });
      }
    }

    function getActiveIframeEl() {
      const c = lastContents || rendition?.getContents?.()?.[0];
      if (!c) return null;

      return (
        c.iframe ||
        c.document?.defaultView?.frameElement ||
        c.window?.frameElement ||
        null
      );
    }

    function syncTocActive() {
      const loc = rendition?.currentLocation?.();
      const curFile = normalizeFileHref(loc?.start?.href || "");
      if (!curFile) return;

      const iframe = getActiveIframeEl();
      if (!iframe) return;

      const candidates = tocFlat.filter(
        it => it.fileNorm === curFile && it.targetEl
      );
      if (!candidates.length) return;

      const scale = getScaleFromRect(stage);
      const iframeRect = iframe.getBoundingClientRect();
      //const viewportTop = iframeRect.top + 20;

      const viewportTop = 20; // iframe 내부 기준
      const viewportBottom = lastContents.window.innerHeight; // 또는 doc.documentElement.clientHeight

      const iframeLeft = -(iframeRect.left / scale) + 200;

      let max_left = 0;
      let best = null;
      let bestDist = Infinity;

      for (const it of candidates) {
        const r = it.targetEl.getBoundingClientRect();
        const dist = Math.abs(r.top - viewportTop);

        if (r.left <= iframeLeft && r.left > max_left) {
          max_left = r.left;
          best = it;
        }
      }

      if (!best) return;

      if (tocLastActiveEl && tocLastActiveEl !== best.el) {
        tocLastActiveEl.classList.remove("active");
      }
      best.el.classList.add("active");
      tocLastActiveEl = best.el;

      if (tocOpen) {
        best.el.scrollIntoView({ block: "center", behavior: "smooth" });
      }
    }

    let tocClickTF = false;

    async function renderToc() {
      tocBody.innerHTML = "";
      tocFlat = [];
      clearTocActive();

      if (!book) return;

      let nav = null;
      try {
        nav = await book.loaded.navigation;
      } catch {
        nav = null;
      }

      const toc = nav?.toc || [];

      if (!toc || toc.length === 0) {
        const empty = document.createElement("div");
        empty.className = "toc-empty";
        empty.textContent = "이 EPUB에는 목차가 없습니다.";
        tocBody.appendChild(empty);
        return;
      }

      const ul = document.createElement("ul");
      ul.className = "toc-list";

      function addItems(items, depth) {
        for (const item of items) {
          const li = document.createElement("li");
          li.className = `toc-item toc-indent-${Math.min(depth, 5)}`;

          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "toc-link";
          btn.innerHTML = `<span class="label">${escapeHtml(safeLabel(item))}</span>`;

          const hrefRaw = item?.href || item?.url || "";
          const fileNorm = normalizeFileHref(hrefRaw);
          const frag = getFrag(hrefRaw); // 이미 함수 있음

          tocFlat.push({ fileNorm, frag, el: btn, cfi: null, hrefRaw, targetEl: null });

          btn.addEventListener("click", async () => {
            if (!rendition) return;
            if (!hrefRaw) return;
            try {
              tocClickTF = true;
              await rendition.display(hrefRaw); // 권장: 원본 href로 정확 이동
              // 이동 후 relocated에서 active가 다시 잡히지만,
              // UX상 즉시 반영도 같이 해줌(패널 유지 정책)
              setTocActiveEl(btn, true);
            } catch (err) {
              console.warn("TOC display failed:", err);
            }
          });

          li.appendChild(btn);
          ul.appendChild(li);

          if (item?.subitems?.length) {
            addItems(item.subitems, depth + 1);
          } else if (item?.children?.length) {
            addItems(item.children, depth + 1);
          }
        }
      }

      addItems(toc, 0);
      tocBody.appendChild(ul);

      // 최초 하이라이트 동기화(패널이 닫혀 있어도 active는 맞춰둠)
      syncTocActive();
    }

    function escapeHtml(str) {
      return String(str)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    async function getMidCfiFromCurrentLocation() {
      if (!rendition) return null;
      const loc = rendition.currentLocation();
      const startCfi = loc?.start?.cfi;
      const endCfi   = loc?.end?.cfi;
      if (!startCfi) return null;

      // locations 준비되어 있어야 함
      await ensureLocations(); // 너 코드에 이미 있는 함수 호출 :contentReference[oaicite:4]{index=4}

      const p1 = book.locations.percentageFromCfi(startCfi);
      const p2 = endCfi ? book.locations.percentageFromCfi(endCfi) : p1;
      const mid = (p1 + p2) / 2;

      return book.locations.cfiFromPercentage(mid);
    }

    async function restore(cfi, pct, href) {
      restoring = true;
      restoreDoneAt = 0;

      try {
      await book.ready;
      await ensureLocations();

      if (href) {
        try { await rendition.display(href); } catch {}
      }
      if (typeof pct === "number") {
        const cfi2 = book.locations.cfiFromPercentage(pct);
        try {
          await rendition.display(cfi2);
          await new Promise(r => setTimeout(r, 200));
          await rendition.display(cfi2);
          //setTimeout(() => { restoring = false; }, 200);
          return;
        } catch {}
      }
      if (cfi) {
        try { await rendition.display(cfi); return; } catch {}
      }
      await rendition.display();
      } finally {
        restoreDoneAt = Date.now();
        setTimeout(() => {
          restoring = false;
          syncProgressUI();
          if (!tocClickTF) syncTocActive();
        }, 300);
      }
    }

    let lastContents = null;
    let restoring = false;

    async function initRendition() {
      if (!book) return;
      viewerEl.innerHTML = "";

      rendition = book.renderTo(viewerEl, {
        width: "100%",
        height: "100%",
        //spread: "none",
        spread: "always",
        flow: "paginated",
        manager: "default"
      });

      rendition.themes.default({
        "body": {
          "margin": "0",
          "padding": "48px 64px",
          "line-height": "1.7",
          "color": "#111",
          "background": "#fff"
        }
      });

      book.loaded?.metadata?.then(meta => {
        if (meta?.title) bookTitleEl.textContent = meta.title;
      }).catch(()=>{});

      // 렌더될 때마다 iframe 이벤트 바인딩
      rendition.on("rendered", (section, contents) => {
        console.log('render');
        lastContents = contents;

        if (!firstRendered) {
          firstRendered = true;
          hideBookLoading();
        }

        hydrateTocCfi(section, contents);
        bindEdgeOverlayForContents(contents);
        bindMenuToggleForContents(contents);
        bindKeyEvents(contents);

        // 사전
        rendition.getContents().forEach((contents) => {
            // 이 안에서 이벤트 바인딩 / CSS 주입
            setupDictionaryHover(contents);
        });

        // 보기설정(테마/폰트/크기/자간/행간) 재적용: 렌더링마다 iframe 문서가 바뀔 수 있음
        applySettingsToContents(contents, loadSettings());
        applyThemeClass(loadSettings().theme);

        // 포커스 안정화(키 이벤트가 iframe에 들어가도록)
        try {
          contents.iframe.setAttribute("tabindex", "-1");
          // 목차가 열려있으면 굳이 iframe에 포커스 강제 안 해도 되지만,
          // 페이지 넘김 키는 계속 iframe에서 잡는 게 편해서 그대로 둠
          contents.iframe.focus({ preventScroll: true });
        } catch(e) {}
      });

      // 페이지가 바뀌면 진행 UI + TOC 동기화
      rendition.on("relocated", async (loc) => {
        syncProgressUI();
        console.log('relocate');

        if (restoring) return;
        if (restoreDoneAt && Date.now() - restoreDoneAt < 300) return;

        // cfi 저장
        const cfi = loc?.start?.cfi;
        const pct = cfi ? book.locations.percentageFromCfi(cfi) : null;
        const href = loc?.start?.href || null;

        debouncedSaveCfi({ cfi, pct, href });

        localStorage.setItem(`epub-locations:${MY_EBOOK_ISBN}`, book.locations.save());

        const cards = document.querySelectorAll(".book-card");
        cards.forEach((card) => {
          if(card.dataset.isbn !== MY_EBOOK_ISBN) return;
          const fill = card.querySelector(".progress-fill");

          if (fill) {
            fill.style.width = `${pct * 100}%`;
          }
        });

        // 요구사항: 페이지 이동마다 하이라이트 + 자동 스크롤 갱신
        // 단, 목차를 클릭해서 이동할땐 무시
        if(!tocClickTF) syncTocActive();
        tocClickTF = false;
      });

      const startCfi = LAST_CFI || undefined;
      const startPct = LAST_PCT || undefined;
      const startHref = LAST_HREF || undefined;

      restore(startCfi, startPct, startHref);

      // TOC 렌더(한 번)
      renderToc();
    }

    // ====== 페이지 로드 ======
    (async function () {
      if(MY_EBOOK_ISBN) {
          showBookLoading();

          // 기존 정리
          if (rendition) {
            try { rendition.destroy(); } catch {}
            rendition = null;
          }
          if (book) {
            try { book.destroy(); } catch {}
            book = null;
          }
          viewerEl.innerHTML = "";

          setMenusOpen(false);
          setTocOpen(false);

          const url = `/ebook/epub/${MY_EBOOK_ISBN}`;

          const res = await fetch(url);
          if (!res.ok) throw new Error("EPUB fetch failed: " + res.status);

          buf = await res.arrayBuffer();

          book = ePub(buf);

          initRendition();
      }
    })();


    // ====== CFI 저장 ======
    // debounce 유틸
    function debounce(fn, delay) {
      let timer = null;
      return function (...args) {
        clearTimeout(timer);
        timer = setTimeout(() => fn.apply(this, args), delay);
      };
    }

    // - PUT  /api/ebook-history/{isbn13}  body: { cfi: "..." }
    async function saveLastCfi(loc_info, { keepalive = false } = {}) {
      //if (!isbn13 || !cfi) return;
      if (!loc_info.cfi) return;

      try {
        await fetch(`/ebook/history/${encodeURIComponent(MY_EBOOK_ISBN)}`, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ cfi:loc_info.cfi, pct:loc_info.pct, href:loc_info.href }),
          keepalive
        });
      } catch {
        // 저장 실패는 UX에 치명적이지 않으니 조용히 무시(원하면 console.log)
        console.log('실패?');
      }
    }

    const debouncedSaveCfi = debounce(saveLastCfi, 3000);


    // ====== 페이지 이동 ======
    function goPrev() { if (rendition) rendition.prev(); }
    function goNext() { if (rendition) rendition.next(); }

    function bindKeyEvents(contents) {
      const doc = contents.document;
      if (doc.__keyBound) return;
      doc.__keyBound = true;

      doc.addEventListener("keydown", (e) => {
        const t = e.target;
        const isTyping = t && (t.tagName === "INPUT" || t.tagName === "TEXTAREA" || t.isContentEditable);
        if (isTyping) return;

        if (e.key === "ArrowLeft") { e.preventDefault(); goPrev(); closeModal(); }
        if (e.key === "ArrowRight") { e.preventDefault(); goNext(); closeModal(); }
        if (e.key === "Escape" && settingsOpen) { e.preventDefault(); setSettingsOpen(false); }
      });
    }

    function refocusViewer() {
      try {
        // 현재 렌더된 iframe 문서로 포커스 복구
        const c = rendition?.getContents?.()?.[0];
        c?.window?.focus?.();
        c?.document?.body?.focus?.();
      } catch {}
    }


    // ====== 오버레이 표시(iframe 내부 mousemove 기준) ======
    function bindEdgeOverlayForContents(contents) {
      const doc = contents.document;
      const iframeEl = contents.iframe;
      if (doc.__edgeBound) return;
      doc.__edgeBound = true;

      function onMove(e) {
        const scale = getScaleFromRect(stage);
        const shellRect = shell.getBoundingClientRect();
        const iframeRect = iframeEl.getBoundingClientRect();

        const clientX = (e.clientX * scale) + iframeRect.left;
        const clientY = (e.clientY * scale) + iframeRect.top;

        const inside =
          clientX >= shellRect.left && clientX <= shellRect.right &&
          clientY >= shellRect.top  && clientY <= shellRect.bottom;

        if (!inside) {
          navLeft.classList.remove("show");
          navRight.classList.remove("show");
          return;
        }

        const x = clientX - shellRect.left;
        const inLeft  = x >= 0 && x < (EDGE * scale);
        const inRight = x <= shellRect.width && x > shellRect.width - (EDGE * scale);

        navLeft.classList.toggle("show", inLeft);
        navRight.classList.toggle("show", inRight);

        if (!inLeft && !inRight) {
          navLeft.classList.remove("show");
          navRight.classList.remove("show");
        }
      }

      doc.addEventListener("mousemove", onMove, { passive: true });
    }

    navLeft.addEventListener("click", (e) => { e.preventDefault(); goPrev(); });
    navRight.addEventListener("click", (e) => { e.preventDefault(); goNext(); });

    // ====== 책 영역 클릭(좌/우 오버레이 제외) => 상/하단 메뉴 토글 ======
    function bindMenuToggleForContents(contents) {
      const doc = contents.document;
      const iframeEl = contents.iframe;

      if (doc.__menuBound) return;
      doc.__menuBound = true;

      doc.addEventListener("click", (e) => {
        if (!book) return;

        closeLibrary();

        if (dictMode && wordClick) {
          wordClick = false;
          return;
        }

        const scale = getScaleFromRect(stage);
        const iframeRect = iframeEl.getBoundingClientRect();
        const clientX = (e.clientX * scale) + iframeRect.left;

        handleMenuToggleByClick(clientX);
      });
    }

    shell.addEventListener("click", (e) => {
      if (book) return;
      handleMenuToggleByClick(e.clientX);
    });

    function handleMenuToggleByClick(clientX) {
      const rect = shell.getBoundingClientRect();
      const x = clientX - rect.left;

      if (x >= 0 && x < EDGE) return;
      if (x > rect.width - EDGE) return;

      toggleMenus();
    }

    // ====== 진행바: 드래그하는 동안 실시간 이동(스프레드=1페이지), 페이지 단위 ======
    progressRange.addEventListener("input", async () => {
      if (!book?.locations?.total) return;
      isScrubbing = true;
      const target = Number(progressRange.value);
      pageInput.value = String(target);
      await goToSpreadPage(target);
      isScrubbing = false;
    });

    // ====== 페이지 입력: 스프레드 페이지 번호 기준 이동 ======
    function commitPageInput() {
      const v = clamp(Number(pageInput.value) || 1, 1, totalSpreads);
      pageInput.value = String(v);
      progressRange.value = String(v);
      goToSpreadPage(v);
    }

    pageInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        commitPageInput();
        pageInput.blur();
      }
    });
    pageInput.addEventListener("blur", () => {
      commitPageInput();
    });

    // ====== 사전 모달 ======
    const modal = document.querySelector("#dict_modal_overlay");
    const dictBtn = document.querySelector("#dictBtn");
    let audioUrl;
    let dictMode = false;

    dictBtn.addEventListener('click', () => {
      clearAllHighlight();
      if(!dictMode) {
        dictBtn.classList.add("active");
      }
      else {
        dictBtn.classList.remove("active");
      }
      dictMode = !dictMode;
    });

    function playPronunciation() {
      const audio = new Audio(audioUrl);
      audio.play();
      refocusViewer();
    }

    function showDictLoading(word){
      // 모달 헤더는 즉시 반응
      document.querySelector('.headword').textContent = word || "단어";
      document.querySelector('.phon').innerHTML = '';
      document.querySelector('.phonetic_mp3_btn').style.display = 'none';
      document.querySelector('.dict_license').textContent = '';

      // 본문은 로딩 UI로 교체
      document.querySelector('.modal_ul').innerHTML = `
        <div class="dict-loading">
          <span class="dict-spinner" aria-hidden="true"></span>
          <span>불러오는 중…</span>
        </div>
        <div class="dict-skel" aria-hidden="true">
          <div class="dict-skel-line w60"></div>
          <div class="dict-skel-line w95"></div>
          <div class="dict-skel-line w85"></div>
        </div>
      `;
    }

    function showDictError(msg){
      document.querySelector('.modal_ul').innerHTML = `
        <div class="dict-error">${msg || "사전 정보를 불러오지 못했어요."}</div>
      `;
    }

    function getWordMeaning(word) {
        var fetchUrl = "/ebook/dict/" + word;
        //var fetchUrl = "https://api.dictionaryapi.dev/api/v2/entries/en/" + word;
        fetch(fetchUrl)
        .then((response) => response.json())
        .then((datas) => {
            document.querySelector('.headword').textContent = datas.word;
            document.querySelector('.phonetic_mp3_btn').style.display = 'none';

            const phonDiv = document.querySelector('.phon');
            const limit = datas.phonetics.length >= 3 ? 3 : datas.phonetics.length;

            phonDiv.innerHTML = '';
            datas.phonetics.slice(0, limit).forEach((p) => {
              const ph = p.text;
              if(!ph) return;

              const audio = p.audio;
              if(audio) {
                audioUrl = audio;
                document.querySelector('.phonetic_mp3_btn').style.display = 'block';
              }

              let span = document.createElement('span');
              span.textContent = ph;
              span.classList.add('pill');
              phonDiv.appendChild(span);
            });

            let htmlStr = '';
            datas.meanings.forEach((mean) => {
                htmlStr += `<li class="modal_li">
                <h4><span class="speech">${mean.partOfSpeech}</span></h4>
                <ol class="dict_modal_body">`;

                mean.definitions.forEach(def => {
                    htmlStr += `<li>${def.definition}</li>`;
                });

                htmlStr += `</ol></li>`;
            });
            document.querySelector('.modal_ul').innerHTML = htmlStr;
            document.querySelector('.dict_license').textContent = datas.license.name;
        })
        .catch(err => {
          console.log(err);
          showDictError("사전 정보를 불러오지 못했습니다.");
        });
    }

    function clearAllHighlight() {
      rendition.getContents().forEach((contents) => {
        const highlights = contents.document.querySelectorAll(".dict-word-highlight");
        highlights.forEach((el) => {
          const parent = el.parentNode;
          while (el.firstChild) parent.insertBefore(el.firstChild, el);
          parent.removeChild(el);
        });
      });
    }

    function clearWordHighlight(doc, word) {
      const prev = doc.querySelectorAll(".dict-word-highlight");
      prev.forEach((el) => {
        if(word !== null && el.textContent == word) return;
        const parent = el.parentNode;
        while (el.firstChild) parent.insertBefore(el.firstChild, el);
        parent.removeChild(el);
      });
    }

    function highlightWordRange(doc, range) {
      const span = doc.createElement("span");
      span.className = "dict-word-highlight";
      range.surroundContents(span);
    }

    function injectDictCss(contents) {
      const doc = contents.document;
      if (doc.getElementById("dict-style")) return;

      const style = doc.createElement("style");
      style.id = "dict-style";
      style.textContent = `
        .dict-word-highlight {
          background-color: rgba(255, 230, 150, 0.8);
          cursor: pointer;
          border-radius: 2px;
          transition: background-color 0.1s ease;
        }
      `;
      doc.head.appendChild(style);
    }


    function getWordAtPoint(win, x, y) {
      let range;
      if (win.document.caretRangeFromPoint) {
        range = win.document.caretRangeFromPoint(x, y);
      } else if (win.document.caretPositionFromPoint) {
        const pos = win.document.caretPositionFromPoint(x, y);
        range = win.document.createRange();
        range.setStart(pos.offsetNode, pos.offset);
        range.collapse(true);
      } else {
        return null;
      }

      if (!range || !range.startContainer || range.startContainer.nodeType !== Node.TEXT_NODE) {
        return null;
      }

      const textNode = range.startContainer;
      const offset = range.startOffset;
      const text = textNode.textContent;

      // offset 기준으로 좌우로 단어 경계 찾기 (공백/구두점 기준)
      const isWordChar = (ch) => /\w/.test(ch || "");

      let start = offset;
      while (start > 0 && isWordChar(text[start - 1])) start--;

      let end = offset;
      while (end < text.length && isWordChar(text[end])) end++;

      if (start === end) return null;

      const word = text.slice(start, end);

      const wordRange = win.document.createRange();
      wordRange.setStart(textNode, start);
      wordRange.setEnd(textNode, end);

      return { word, range: wordRange };
    }

    /**
     * (left, top)을 stage 좌표계 기준으로 넣으면
     * 모달이 stage 밖으로 안 나가게 보정해서 반환
     */
    function fitModalIntoStage(modalEl, left, top, gap = 12){
      const stageRect = stage.getBoundingClientRect();
      const scale = getScaleFromRect(stage);

      // 모달 크기(표시 전이면 0일 수 있으니 fallback)
      const mw = modalEl.offsetWidth  || 280;
      const mh = modalEl.offsetHeight || 220;

      // stage 좌표계에서의 "허용 범위"
      const minX = gap;
      const minY = gap;
      const maxX = (stageRect.width  / scale) - mw - gap;
      const maxY = (stageRect.height / scale) - mh - gap;

      return {
        left: clamp(left, minX, maxX),
        top:  clamp(top,  minY, maxY),
      };
    }


    let wordClick = false;
    let lastWord = null;
    function setupDictionaryHover(contents) {
      injectDictCss(contents);
      const doc = contents.document;
      const win = contents.window;

      // 사전 모드일 때만 동작하도록
      doc.addEventListener("mousemove", (e) => {
        if (!dictMode) return;

        const wordInfo = getWordAtPoint(win, e.clientX, e.clientY);

        if(wordInfo === null) {
            clearWordHighlight(doc, null);
        }
        else {
            if (wordInfo.word !== lastWord) {
              clearWordHighlight(doc, wordInfo.word);
              setTimeout(() => {highlightWordRange(doc, wordInfo.range); lastWord = wordInfo.word;}, 10);
              //highlightWordRange(doc, wordInfo.range);
              //lastWord = wordInfo.word;
            }
        }
      });

      doc.addEventListener("click", (e) => {
        if (!dictMode) return;

        const wordInfo = getWordAtPoint(win, e.clientX, e.clientY);
        if (!wordInfo) {closeModal(); return;}

        wordClick = true;

        // 클릭한 단어를 감싼 highlight span 찾기
        const highlighted = doc.querySelector(".dict-word-highlight");
        if (!highlighted) return;

        // iframe 내부의 좌표
        const scale = getScaleFromRect(stage);
        const rect = highlighted.getBoundingClientRect();
        const iframeEl = contents.iframe || contents.document.defaultView.frameElement;
        const iframeRect = iframeEl.getBoundingClientRect();

        modal.style.display = "block";

        // 모달 위치: 단어의 바로 아래
        let modalLeft = rect.left + (iframeRect.left / scale);
        let modalTop = rect.bottom + rect.height;

        // stage 밖으로 넘치면 보정
        const fitted = fitModalIntoStage(modal, modalLeft, modalTop, 14);
        modal.style.left = fitted.left + "px";
        modal.style.top  = fitted.top  + "px";

        showDictLoading(wordInfo.word);
        getWordMeaning(wordInfo.word);
      });
    }

    function closeModal() {
      modal.style.display = 'none';
      document.querySelector('.phonetic_mp3_btn').style.display = 'none';
    }

    window.addEventListener('click', function(e) {
      if (e.target !== modal) {
        //console.log('window');
        //closeModal();
      }
    });

    /* =========================
       EPUB Progress Utilities
       ========================= */

    const LOCATION_CHARS = 1600;

    /**
     * ISBN 기준으로 locations 준비
     */
    async function prepareLocations(book, isbn) {
      const key = `epub-locations:${isbn}`;
      const saved = localStorage.getItem(key);

      if (saved) {
        book.locations.load(saved);
        return;
      }

      await book.locations.generate(LOCATION_CHARS);
      localStorage.setItem(key, book.locations.save());
    }

    /**
     * CFI → 진행률 계산 (0~100)
     */
    async function calcProgressPercentByCfi(epubUrl, cfi, isbn) {
      if (!cfi || !isbn) return 0;

      const res = await fetch(epubUrl);
      if (!res.ok) throw new Error("EPUB fetch failed: " + res.status);

      buf = await res.arrayBuffer();

      const book = ePub(buf);
      if(!book) {
        console.log('대여중인 도서가 아닙니다');
        return;
      }

      await book.ready;
      await prepareLocations(book, isbn);

      const percent = book.locations.percentageFromCfi(cfi);
      book.destroy?.(); // 메모리 정리 (epub.js 버전에 따라 optional)

      if (isNaN(percent)) return 0;
      return Math.floor(percent * 100);
    }


    // ====== 내 서재 패널 ======
    // IIFE : 즉시 실행 함수
    // 함수를 정의하자마자 즉시 실행함
    let libraryOpen = false;

    function closeLibrary() {
      shell.classList.remove("library-open");
      libraryOpen = false;
    }

    (function () {
      const shell = document.getElementById("shell");
      const fab = document.getElementById("libraryFab");
      const panel = document.getElementById("libraryPanel");
      const closeBtn = document.getElementById("libraryClose");

      if (!shell || !fab || !panel) return;

      function toggleLibrary() {
        shell.classList.toggle("library-open");
        libraryOpen = !libraryOpen;
      }

      /* FAB 클릭 → 토글 */
      fab.addEventListener("click", (e) => {
        e.stopPropagation(); // 바깥 클릭으로 바로 닫히는 것 방지
        toggleLibrary();
      });

      /* 닫기 버튼 */
      if (closeBtn) {
        closeBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          closeLibrary();
        });
      }

      /* 패널 내부 클릭은 닫히지 않게 */
      panel.addEventListener("click", (e) => {
        e.stopPropagation();
      });

      /* 문서 바깥 클릭 → 닫기 (backdrop 없이 구현) */
      document.addEventListener("click", () => {
        if (shell.classList.contains("library-open")) {
          closeLibrary();
        }
      });
    })();

    // ====== 내 서재 패널 채우기 ======
    (function () {

      const grid = document.getElementById("libraryGrid");
      if (!grid) return;

    function createBookCard(item) {
      const card = document.createElement("button");
      card.className = "book-card";
      card.type = "button";
      card.dataset.lendId = item.lendId;
      card.dataset.bookId = item.bookId;
      card.dataset.isbn = item.isbn13 || "";

      card.innerHTML = `
        <div class="cover-wrap">
          <img class="book-cover"
               src="${item.coverUrl || 'https://via.placeholder.com/300x420?text=No+Cover'}"
               alt="${item.bookTitle}">
          ${item.ebookYN === 'Y'
            ? `<span class="badge-ebook" aria-label="전자책">E</span>`
            : ``}
        </div>

        <div class="book-meta">
          <div class="book-title">${item.bookTitle}</div>
          <div class="book-author">${item.authors || ''}</div>

          <div class="progress-row">
            <div class="progress-track">
              <div class="progress-fill" style="width:0%"></div>
            </div>
          </div>
        </div>
      `;

      // 🔥 비동기 진행률 계산
      if (item.cfi) {
        calcProgressPercentByCfi(
          `/ebook/epub/${item.isbn13}`, // 🔸 실제 epub 로딩 API 경로로 교체
          item.cfi,
          item.isbn13
        ).then(percent => {
          const fill = card.querySelector(".progress-fill");

          if (fill) {
            fill.style.width = `${percent}%`;
          }
        }).catch(() => {
          // 계산 실패 시 조용히 무시
        });
      }

      // 이벤트 리스너 추가
      card.addEventListener('click', () => {
        window.location.href = `/ebook/${item.bookId}`;
      });

      return card;
    }


      function renderLibrary(list) {
        grid.innerHTML = "";

        if (!list || list.length === 0) {
          grid.innerHTML = `
            <div style="grid-column:1/-1; padding:20px; text-align:center; color:rgba(0,0,0,.55)">
              대여 중인 전자책이 없습니다.
            </div>
          `;
          return;
        }

        list.forEach(item => {
          grid.appendChild(createBookCard(item));
        });
      }

      /* 최초 렌더 */
      if (MY_EBOOK_LIST) {
        renderLibrary(MY_EBOOK_LIST);
      }

    })();
</script>
</body>
</html>
